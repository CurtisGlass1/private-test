<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Transakt.WinRT</name>
    </assembly>
    <members>
        <member name="M:Entersekt.Transakt.Security.SecureRandom.Entersekt#Transakt#Security#ISecureRandom#NextBytes(System.UInt32)">
            <summary>
            Populates a byte array of the given size with random data.
            </summary>
            <param name="size">Integer specifying the desired size of the returned byte array</param>
            <returns>Random byte array of specified size</returns>
        </member>
        <member name="M:Entersekt.Transakt.Security.AesGcm.Encrypt(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Encryption And Authentication (AES-GCM) of a byte array.
            </summary>
            <param name="secretMessage">The secret message.</param>
            <param name="key">The key.</param>
            <param name="nonSecretPayload">Optional non-secret payload.</param>
            <returns>Encrypted Message</returns>
            <remarks>
            Adds overhead of (Optional-Payload + BlockSize(16) + Message +  HMac-Tag(16)) * 1.33 Base64
            </remarks>
        </member>
        <member name="M:Entersekt.Transakt.Security.AesGcm.Decrypt(System.Byte[],System.Byte[],System.Int32)">
            <summary>
            Decryption and Authentication (AES-GCM) of a byte array
            </summary>
            <param name="encryptedMessage">The encrypted message.</param>
            <param name="key">The key.</param>
            <param name="nonSecretPayloadLength">Length of the optional non-secret payload.</param>
            <returns>Decrypted Message</returns>
        </member>
        <member name="M:Entersekt.Transakt.Security.IAppGuidProvider.GetAppGuid">
            <summary>
            Retrieve the 128 bit GUID value of the app id
            </summary>
            <returns>A byte array containing the 128 bit app ID GUID value</returns>
        </member>
        <member name="M:Entersekt.Transakt.Security.ISecureRandom.NextBytes(System.UInt32)">
            <summary>
            Populates a byte array of the given size with cryptographically secure random data.
            </summary>
            <param name="size">Integer specifying the desired size of the returned byte array</param>
            <returns>A byte array of random data</returns>
        </member>
        <member name="M:Entersekt.Transakt.Security.ISharedKeyProvider.GetSharedKey">
            <summary>
            Retrieve initial key material from a secure local store.
            If there is none, return null
            </summary>
            <returns>A byte array of once-off random data</returns>
        </member>
        <member name="M:Entersekt.Transakt.Security.ISharedKeyProvider.CreateSharedKey">
            <summary>
            Create initial key material and save in a secure local store.
            </summary>
            <returns>A byte array of once-off random data</returns>
        </member>
        <member name="M:Entersekt.Transakt.Security.OtpGenerator.Generate(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates OATH OTP
            
            http://www.ietf.org/rfc/rfc4226.txt
            
            Step 1: Generate an HMAC-SHA-1 value.
                Let HS = HMAC-SHA-1(K,C)
                HS is a 20-byte string.
            Step 2: Generate a 4-byte string (Dynamic Truncation).
                Let Sbits = DT(HS)
                DT, defined below, returns a 31-bit string
            Step 3: Compute an HOTP value.
                Let Snum = StToNum(Sbits)
                Convert S to a number in 0...2^{31}-1
                Return D = Snum mod 10^Digit D is a number in the range 0...10^{Digit}-1
            </summary>
            <param name="secretKey">secret shared secret key (seed)</param>
            <param name="movingFactor">seed offset</param>
            <param name="codeDigits">number of digits to encode result in; 6 minimum</param>
            <param name="truncationOffset">position in hash to use; if == 16, dynamic truncation will be utilized</param>
            <param name="baseToUse"></param>
            <returns>the generated OTP as a string</returns>
        </member>
        <member name="M:Entersekt.Transakt.Security.StorageKeyGenerator.Create(System.Byte[],System.Boolean)">
            <summary>
            Gather together various sources of entropy to create the encryption key for a storage entry
            </summary>
            <param name="additionalEntropy">A byte array of extra entropy. Typically derived from the key associated with a value.</param>
            <param name="forStore">A boolean indicating if this is being generated for storing (rather than fetching) a value.
            This is used to control logic which decides whether or not the master key is allowed to be generated.</param>
            <returns>A byte array with an (en/de)cryption key.</returns>
        </member>
        <member name="M:Entersekt.Transakt.Security.StorageKeyGenerator.XorOnto(System.Byte[],System.Byte[])">
            <summary>
            Does a byte by byte Xor of x2 ONTO x1 (x1 is modified!).
            The two arrays need not be the same length. The size of x1 remains constant.
            </summary>
            <returns>The modified x1</returns>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.TransaktSdk">
            <summary>
            The TransaktSDK object represents a grouping of functionality related to the Transakt infrastructure.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.TransaktSdk.GetInstance">
            <summary>
            Returns a singleton instance of the Transakt SDK.
            </summary>
            <returns>The async task associated with the GetInstance operation. Task result is the TransaktSDK instance.</returns>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.DataObjects.Auth">
            <summary>
            An Auth represents a grouping of information required to perform real time authentication.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Auth.Id">
            <summary>
            A unique ID associated with auth message.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Auth.Title">
            <summary>
            The title of the auth message. This is usually displayed at the top of the Auth UI component.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Auth.Text">
            <summary>
            The auth content text. This is usually displayed just below the title.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Auth.NameValues">
            <summary>
            A list of NameValue objects. These fields are used to highlight specific key words within the auth message.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Auth.TextBoxes">
            <summary>
            A list objects representing user input fields.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Auth.Buttons">
            <summary>
            A list of possible user responses to the auth. This data is usually rendered as selectable buttons at the bottom of the Auth UI component.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.DataObjects.Auth.Button">
            <summary>
            Represents the user selected response for the Auth message. The Button can be selected to indicate the user response.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Auth.Button.Label">
            <summary>
            The button label. The label is typically displayed as the text on the UI button component.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Auth.Button.Role">
            <summary>
            Typically used to carry UI context from the server to the device.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Auth.Button.Pin">
            <summary>
            Registers the user PIN. Typically captured in the UI component
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Auth.Button.IsPinRequired">
            <summary>
            Indicates if a user PIN is required if the user selects the current button.
            True if a PIN value is required, false if it isn't.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Auth.Button.IsValidationRequired">
            <summary>
            Indicates if the TextBox field inputs should be validated.
            True if the user input in the TextBox fields should be validated, false if it shouldn't.
            Only applicable if there are TextBoxes defined.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Auth.Button.IsSelected">
            <summary>
            Set to indicate if the button has been selected by the user. True if the button is selected, false if it isn't
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.DataObjects.Auth.Button.Select">
            <summary>
            Call to indicate that the button has been selected by the user.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.DataObjects.Auth.NameValue">
            <summary>
            Represents a grouping of two text fields. Typically displayed in the format <b>name:value</b> to highlight important information in the Auth message.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Auth.NameValue.Name">
            <summary>
            The label of the data pair.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Auth.NameValue.Value">
            <summary>
            The content of the data pair. This contains info relating to the 'Name' field.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.DataObjects.Auth.TextBox">
            <summary>
            A TextBox is a grouping of information that relates to rendering a user input field on the UI component.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Auth.TextBox.Label">
            <summary>
            The TextBox label. Usually displayed as a heading for an input field on the UI component.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Auth.TextBox.Text">
            <summary>
            A description of what the user should type into the TextBox. Usually displayed as a 'hint' on the input field on the UI component.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Auth.TextBox.MinSize">
            <summary>
            The minimum user input length. Typically used to perform input validation on the amount of characters that should be entered into the input field.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Auth.TextBox.MaxSize">
            <summary>
            The maximum user input length. Typically used to perform input validation on the amount of characters that should be entered into the input field.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Auth.TextBox.Constraints">
            <summary>
            A collection of strings representing user input constraints. Typically used to configure the UI component input field.
            Values: "any", "emailaddr", "numeric", "phonenumber", "url", "decimal", "password", "uneditable", "sensitive",
            "non_predictive", "initial_caps_word", "initial_caps_sentence".
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Auth.TextBox.UserResponse">
            <summary>
            Registers the user response on the input field.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.DataObjects.Certificate">
            <summary>
            Contains digital certificate data.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.DataObjects.Certificate.DerEncoding">
            <summary>
            The DER encoded certificate data.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.DataObjects.CertificatePinner">
            <summary>
            This class provides a CertificatePinner object that supports pin validation and server pin retrieval.
            This is supported by SG protocol 1.2 onwards
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.CertificatePinner.TrustedCertificates">
            <summary>
            Returns a list of the SG's trusted certificates.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.DataObjects.CertificatePinner.IsValidCertificates(System.Uri,System.Collections.Generic.ICollection{System.Byte[]})">
            <summary>
            Validates the supplied certificate(s) against the SG's trusted certificate list for a specific host.
            </summary>
            <param name="url">The URL that should be validated</param>
            <param name="certificates">The certificate(s) associated with the hostname</param>
            <returns>True if any of the certificates are valid</returns>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.DataObjects.CertificatePinner.IsTrustedCertificate(System.Byte[])">
            <summary>
            Validates the supplied leaf certificate against the SG certificate list.
            </summary>
            <param name="certificate"></param>
            <returns>True if certificate is valid</returns>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.DataObjects.ConnectionContext">
            <summary>
            Represents the current state of the Transakt SDK connection.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.ConnectionContext.Action">
            <summary>
            A value indicating the current Transakt SDK connection activity.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.ConnectionContext.Event">
            <summary>
            A value indicating the event that is responsible for the current connection action.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.DataObjects.EmCert">
            <summary>
            Contains all information relating to the service emCert.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.EmCert.EmCertId">
            <summary>
            The unique identifier associated with the emCert.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.EmCert.CertificateChain">
            <summary>
            The certificate chain associated with the emCert.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.DataObjects.Error">
            <summary>
            Error class is used to describe error conditions that can occur in the SDK
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Error.Message">
            <summary>
            The message associated with this Error.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Error.Type">
            <summary>
            The enumeratation type of the Error.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.DataObjects.Error.ToString">
            <summary>
            The message associated with this Error.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.DataObjects.Info">
            <summary>
            The Info class represents a grouping of data relating to device, and SDK information.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Info.Version">
            <summary>
            The Transakt SDK Version
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Info.OsPrivilege">
            <summary>
            This indicates whether the device operating system security permission has been tampered with or not.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.DataObjects.Notify">
            <summary>
            A Notify represents a grouping of info used to show the user a quick message.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Notify.Type">
            <summary>
            Indicates the type of Notify sent. Used to provide additional message context. For example "error", "info".
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Notify.Text">
            <summary>
            Provides the Notify text to be displayed to the user.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.DataObjects.Otp">
            <summary>
            This class provides an OTP generator with support for both standard, and time based OTPs.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Otp.IsPinEnabled">
            <summary>
            Indicates whether a PIN is required to generate an OTP. True if a PIN is required, false if it isn't.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Otp.TimestepSeconds">
            <summary>
            The time based OTP validity period, per OTP. Only relevant for time based OTPs. If the OTP is not time based, returns 0.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Otp.ExpiresInMillis">
            <summary>
            The time left, in milliseconds, until the OTP expires. Only relevant for time based OTPs. If the OTP is not time based, returns -1.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.DataObjects.Otp.GetValue">
            <summary>
            Generates an OTP value.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.DataObjects.Otp.GetValue(System.String)">
            <summary>
            Generates an OTP value with the supplied PIN.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.DataObjects.Signup">
            <summary>
            A grouping of data related to performing a signup request.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.Signup.SignupCode">
            <summary>
            The signup code used to perform the signup operation.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.DataObjects.Signup.#ctor(System.String)">
            <summary>
            The signup code is usually provided on a different channel in order to link the user with an emCertID.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.DataObjects.TData">
            <summary>
            A grouping of data to be sent on the TData operation.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.TData.Payload">
            <summary>
            Registers the payload to be sent with the TData operation. 
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.DataObjects.TData.#ctor(System.String)">
            <summary>
            The payload size may be up to 4096 bytes based on UTF-8 string encoding.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.DataObjects.TrustToken">
            <summary>
            Contains information relating to a Trust Token.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.DataObjects.TrustToken.Token">
            <summary>
            The Trust Token generated by the Secure Gateway.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.Enums.ConnectionActions">
            <summary>
            A value indicating the current Transakt SDK connection activity.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.ConnectionActions.NoAction">
            <summary>
            Indicates that the connection is stable in the current state, and that no action is being performed.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.ConnectionActions.Connecting">
            <summary>
            Indicates that the Transakt SDK is trying to establish a connection to the Transakt infrastructure.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.ConnectionActions.Disconnecting">
            <summary>
            Indicates that the Transakt SDK is disconnecting from the Transakt infrastructure.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.Enums.ConnectionEvents">
            <summary>
            A value indicating the event that is responsible for the current connection action.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.ConnectionEvents.SdkReady">
            <summary>
            Indicates that the Transakt SDK has been initialized.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.ConnectionEvents.ConnectCalled">
            <summary>
            Indicates that the connect function was called on the Transakt SDK.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.ConnectionEvents.DisconnectCalled">
            <summary>
            Indicates that the disconnect function was called on the Transakt SDK.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.ConnectionEvents.ServerTimeout">
            <summary>
            Indicates a timeout event on the connection.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.ConnectionEvents.Reconnect">
            <summary>
            Indicates a connection retry after a server timeout has occurred.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.ConnectionEvents.NoData">
            <summary>
            Indicates that the Transakt SDK detected that a data connection is no longer available.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.ConnectionEvents.Data">
            <summary>
            Indicates that the Transakt SDK detected that a data connection is available.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.Enums.Errors">
            <summary>
            An enumeration of the error conditions that can occur in the SDK.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.Errors.SdkDisconnected">
            <summary>
            Transakt SDK must be connected to perform this operation.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.Errors.OperationTimedOut">
            <summary>
            The operation has timed out.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.Errors.OperationRemoteError">
            <summary>
            An error occured on the Secure Gateway. See the message text for more info.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.Errors.OperationNotSupported">
            <summary>
            The Secure Gateway does not support the call.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.Errors.ServiceOtpUnavailable">
            <summary>
            OTP functionality is currently unavailable.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.Errors.ServiceUnavailable">
            <summary>
            The service is currently unavailable.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.Errors.ServiceUnregistered">
            <summary>
            The service must be registered to perform this operation.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.Errors.AuthNoPinSet">
            <summary>
            A PIN is required.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.Errors.AuthNoButtonSelected">
            <summary>
            A Button must be set.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.Errors.AuthInvalid">
            <summary>
            An invalid auth was received.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.Errors.AuthAlreadyAnswered">
            <summary>
            Auth was already answered.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.Errors.FieldExceedsMaxSize">
            <summary>
            When the field size is greater than the maximum size limit.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.Errors.FieldNotSet">
            <summary>
            If a required field has not been set.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.Enums.OsPrivilege">
            <summary>
            A value indicating whether the device operating system security permission has been tampered with or not.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.OsPrivilege.Default">
            <summary>
            Indicates that operating system software has not been altered.
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Sdk.Enums.OsPrivilege.Root">
            <summary>
            Indicates that the operating system software has been altered.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Helpers.IAuthOperations.SendAuthEvent(System.String,System.String,Entersekt.Transakt.Json.Router.V1.AuthEvent)">
            <summary>
            Send the relevant AuthEvent to the EMR
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Helpers.IAuthOperations.DownloadAuth(System.String,System.String)">
            <summary>
            Download this specific Auth.
            This method should swallow null and empty strings without throwing exceptions.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Helpers.IAuthOperations.DisplayAuth(Entersekt.Transakt.Sdk.Helpers.AuthInternal)">
            <summary>
            Provide the Auth to the implementer to display with OnAuth
            This method must not block on OnAuth!
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.Helpers.BaseHandler">
            <summary>
            This class contains default implementations for actions.
            If a specific action should be taken instead, the handler should override these methods.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Helpers.TaskExtensions.WithTimeout``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Int32,``0)">
            <summary>
            Add a timeout to this TaskCompletionSource.
            </summary>
            <typeparam name="T">Result type</typeparam>
            <param name="tcs">TaskCompletionSource to which the timeout should apply</param>
            <param name="timeout">Timeout in milliseconds</param>
            <param name="value">Value to return if timeout occurs</param>
            <returns></returns>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Helpers.TaskExtensions.WithTimeout``1(System.Threading.Tasks.TaskCompletionSource{``0},System.TimeSpan,``0)">
            <summary>
            Add a timeout to this TaskCompletionSource.
            </summary>
            <typeparam name="T">Result type</typeparam>
            <param name="tcs">TaskCompletionSource to which the timeout should apply</param>
            <param name="timeout">Timeout</param>
            <param name="value">Value to return if timeout occurs</param>
            <returns></returns>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Helpers.ConversionExtensions.ToJsonInfo(Entersekt.Transakt.Protocol.ServiceInfoData)">
            <summary>
            Note: It's not possible to transfer the extended information with this method.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Helpers.OtpImpl.UpdateParams">
            <summary>
            Update the OTP Params cache variable.
            </summary>
            <returns>A boolean indicating if the updated value is not null.</returns>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Helpers.OtpImpl.TotpExpiresInMillis">
            <summary>
            How many milliseconds until the current totp expires.
            </summary>
            <returns>Milliseconds remaining. Returns -1 if totp is not enabled</returns>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Helpers.OtpImpl.DeviceTimeT0">
            <summary>
            Current device time in total milliseconds since our T0 choice of 1374072555s
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.IConfig">
            <summary>
            The Config class represents a grouping of data that is used to modify the Transakt SDK configuration.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.IConfig.PushChannelUri">
            <summary>
            The unique URI is used to enable push messaging. Set to register the push channel URI associated with the device.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.IConfig.AccessPoint">
            <summary>
            Sets a custom access point for connections
            The access point must be set before the Transakt SDK is connected.
            A custom access point is not needed in most cases and can only be used if pre-arranged with Entersekt.
            </summary>
            <exception cref="T:System.ArgumentNullException">AccessPoint is null</exception>
            <exception cref="T:System.FormatException">invalid AccessPoint was entered</exception>
            <exception cref="T:System.InvalidOperationException">if set after the Transakt SDK has been connected</exception>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.ITransaktSDK">
            <summary>
            The TransaktSDK object represents a grouping of functionality related to the Transakt infrastructure.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.ITransaktSDK.Info">
            <summary>
            The Info object associated with the Transakt SDK.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.ITransaktSDK.Config">
            <summary>
             The config object associated with the Transakt SDK.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.ITransaktSDK.Logger">
            <summary>
            The Transakt SDK logger object. Set a logger to enable Transakt SDK debug logging.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.ITransaktSDK.IsConnected">
            <summary>
            The connection state of the Transakt SDK. True if the Transakt SDK is connected, false if it is disconnected.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.ITransaktSDK.ConnectionContext">
            <summary>
            The ConnectionContext object associated with the current connection status.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.ITransaktSDK.Connect">
            <summary>
            Initiates a connection to the Transakt infrastructure.
            </summary>
            <returns>The async task associated with the connect operation. Task result is True if successful.</returns>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.ITransaktSDK.Disconnect">
            <summary>
            Closes the connection to the Transakt infrastructure.
            </summary>
            <returns>The async task associated with the disconnect operation.</returns>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.ITransaktSDK.RegisteredServices">
            <summary>
            The collection of Service objects that represent each service that the device is registered for.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.ITransaktSDK.GetService(System.String)">
            <summary>
            Returns a service object for the service associated with the given Service ID.
            </summary>
            <param name="serviceId">The unique ID associated with the service.</param>
            <returns>The service object associated with the provided Service ID.</returns>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.ITransaktSDK.SendAuthAnswer(Entersekt.Transakt.Sdk.DataObjects.Auth,Entersekt.Transakt.Sdk.Service.IAuthAnswerCallback)">
            <summary>
            Sends the Auth Answer with the specified data and callback.
            </summary>
            <param name="auth">The Auth data.</param>
            <param name="authAnswerCallback">Callback on which the operation result is returned</param>
            <returns>The async task associated with the AuthAnswer operation.</returns>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.ITransaktSDK.OnConnected">
            <summary>
            The action to execute when a Connected event occurs.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.ITransaktSDK.OnDisconnected">
            <summary>
            The action to execute when a Disconnected event occurs.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.ITransaktSDK.OnRegistered">
            <summary>
            The action to execute when a given service is Registered.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.ITransaktSDK.OnUnregistered">
            <summary>
            The action to execute when a given service is Unregistered.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.ITransaktSDK.OnNotify">
            <summary>
            The action to execute when a Notify arrives for a service.
            The SDK does not handle queueing of multiple Notify messages.
            This method will be called every time a new Notify message is received.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.ITransaktSDK.OnAuth">
            <summary>
            The action to execute when an Auth arrives for a service.
            The SDK handles the queueing of multiple Auth messages. If another Auth is waiting, this method will only
            be called after the answer has been sent for the previous Auth.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.ITransaktSDK.OnTData">
            <summary>
            The action to execute when new TData has been received.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.Logging.ILogger">
            <summary>
            The Logger class represents a grouping of functions that is used to obtain Transakt SDK debug logging information.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Logging.ILogger.Error(System.String)">
            <summary>
            Log Error level messages from the SDK.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Logging.ILogger.Warn(System.String)">
            <summary>
            Log Warning level messages from the SDK.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Logging.ILogger.Debug(System.String)">
            <summary>
            Log Debug level messages from the SDK.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.CertificatePinnerWrapper.OnSuccess">
            <summary>
            The certificatepinner must be set before making this call
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.Service.IAuthAnswerCallback">
            <summary>
            The primary interface a caller must implement to receive a response from the SDK.
            If the Auth Answer was sent successfully, then the success method is called, otherwise the error method is called.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.IAuthAnswerCallback.OnSuccess(Entersekt.Transakt.Sdk.Service.ITransaktService,Entersekt.Transakt.Sdk.DataObjects.Auth)">
            <summary>
            Called when an auth answer was sent successfully.
            </summary>
            <param name="service">The service associated with the operation.</param>
            <param name="auth">The auth data that was sent.</param>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.IAuthAnswerCallback.OnError(Entersekt.Transakt.Sdk.Service.ITransaktService,Entersekt.Transakt.Sdk.DataObjects.Auth,Entersekt.Transakt.Sdk.DataObjects.Error)">
            <summary>
            Called when an error occurred sending the auth answer.
            If a server error occurred, the auth should be sent again.
            If there was an error with the auth data, the error should be corrected before resending the auth.
            </summary>
            <param name="service">The service associated with the operation.</param>
            <param name="auth">The auth data that was sent.</param>
            <param name="error">Indicates which error occured.</param>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.Service.ICertificatePinnerCallback">
            <summary>
            The primary interface a caller must implement to receive a response from the SDK.
            If the Certificate pin was obtained successfully, then the success method is called, otherwise the error method is called.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.ICertificatePinnerCallback.OnSuccess(Entersekt.Transakt.Sdk.Service.ITransaktService,Entersekt.Transakt.Sdk.DataObjects.CertificatePinner)">
            <summary>
            Called when a certificate pinner was obtained successfully.
            </summary>
            <param name="service">The service associated with the operation.</param>
            <param name="certificatePinner">The requested CertificatePinner object.</param>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.ICertificatePinnerCallback.OnError(Entersekt.Transakt.Sdk.Service.ITransaktService,Entersekt.Transakt.Sdk.DataObjects.Error)">
            <summary>
            Called when an error occurred obtaining the certificate pinner.
            </summary>
            <param name="service">The service associated with the operation.</param>
            <param name="error">Indicates which error occured.</param>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.Service.IOtpCallback">
            <summary>
            The primary interface a caller must implement to receive a response from the SDK.
            If an OTP object was created successfully, then the success method is called, otherwise the error method is called.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.IOtpCallback.OnSuccess(Entersekt.Transakt.Sdk.Service.ITransaktService,Entersekt.Transakt.Sdk.DataObjects.Otp)">
            <summary>
            Called when the service OTP object was obtained successfully.
            </summary>
            <param name="service">The service associated with the operation.</param>
            <param name="otp">The OTP object.</param>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.IOtpCallback.OnError(Entersekt.Transakt.Sdk.Service.ITransaktService,Entersekt.Transakt.Sdk.DataObjects.Error)">
            <summary>
            Called when an error occurred obtaining the OTP object.
            </summary>
            <param name="service">The service associated with the operation.</param>
            <param name="error">Indicates which error occured.</param>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.Service.ISignupCallback">
            <summary>
            The primary interface a caller must implement to receive a response from the SDK.
            If the signup code was sent successfully, then the success method is called, otherwise the error method is called.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.ISignupCallback.OnSuccess(Entersekt.Transakt.Sdk.Service.ITransaktService)">
            <summary>
            Called when the signup request is sent successfully.
            </summary>
            <param name="service">The service associated with the operation.</param>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.ISignupCallback.OnError(Entersekt.Transakt.Sdk.Service.ITransaktService,Entersekt.Transakt.Sdk.DataObjects.Error)">
            <summary>
            Called when an error occurred sending the signup request.
            </summary>
            <param name="service">The service associated with the operation.</param>
            <param name="error">Indicates which error occured.</param>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.Service.ITDataCallback">
            <summary>
            The primary interface a caller must implement to receive a response from the SDK.
            If the TData payload was sent successfully, then the success method is called, otherwise the error method is called.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.ITDataCallback.OnSuccess(Entersekt.Transakt.Sdk.Service.ITransaktService)">
            <summary>
            Called when the TData request is sent successfully.
            </summary>
            <param name="service">The service associated with the operation.</param>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.ITDataCallback.OnError(Entersekt.Transakt.Sdk.Service.ITransaktService,Entersekt.Transakt.Sdk.DataObjects.Error)">
            <summary>
            Called when an error occurred sending the TData request.
            </summary>
            <param name="service">The service associated with the operation.</param>
            <param name="error">Indicates which error occured.</param>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.Service.ITransaktService">
            <summary>
            A Service represents a grouping of functionality related to a specific Service ID.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.Service.ITransaktService.Name">
            <summary>
            The name associated with the service.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.Service.ITransaktService.ServiceId">
            <summary>
            The Service ID associated with the service.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.Service.ITransaktService.EmCert">
            <summary>
            The EmCert object associated with the service.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.Service.ITransaktService.IsRegistered">
            <summary>
            The registration state of the service. True if the service is registered, false if it isn't.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.ITransaktService.GetOtp(Entersekt.Transakt.Sdk.Service.IOtpCallback)">
            <summary>
            Returns the OTP object associated with the service.
            </summary>
            <param name="otpCallback">The callback on which the operation result is returned.</param>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.ITransaktService.Signup(Entersekt.Transakt.Sdk.DataObjects.Signup,Entersekt.Transakt.Sdk.Service.ISignupCallback)">
            <summary>
            Sends a signup request to the service.
            </summary>
            <param name="signup">An object containing signup information.</param>
            <param name="signupCallback">The callback on which the operation result is returned.</param>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.ITransaktService.GetCertificatePinner(Entersekt.Transakt.Sdk.Service.ICertificatePinnerCallback)">
            <summary>
            Requests a CertificatePinner
            </summary>
            <param name="certificatePinnerCallback">The callback on which the operation result is returned.</param>
            <exception cref="T:System.ArgumentNullException">certificatePinnerCallback may not be null </exception>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.ITransaktService.GetTrustToken(Entersekt.Transakt.Sdk.Service.ITrustTokenCallback)">
            <summary>
            Requests a new trust token from the service.
            </summary>
            <param name="trustTokenCallback">The callback on which the operation result is returned.</param>
            <exception cref="T:System.ArgumentNullException">trustTokenCallback may not be null</exception>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.ITransaktService.SendTData(Entersekt.Transakt.Sdk.DataObjects.TData,Entersekt.Transakt.Sdk.Service.ITDataCallback)">
            <summary>
            Sends TData with the specified payload and callback.
            </summary>
            <param name="tData">the tdata object</param>
            <param name="tDataCallback">The callback on which the operation result is returned.</param>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.Service.ITrustTokenCallback">
            <summary>
            The primary interface a caller must implement to receive a response from the SDK.
            If the Trust Token was obtained successfully, then the success method is called, otherwise the error method is called.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.ITrustTokenCallback.OnSuccess(Entersekt.Transakt.Sdk.Service.ITransaktService,Entersekt.Transakt.Sdk.DataObjects.TrustToken)">
            <summary>
            Called when a trust token was obtained successfully.
            </summary>
            <param name="service">The service associated with the operation.</param>
            <param name="trustToken">The requested TrustToken.</param>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.ITrustTokenCallback.OnError(Entersekt.Transakt.Sdk.Service.ITransaktService,Entersekt.Transakt.Sdk.DataObjects.Error)">
            <summary>
            Called when an error occurred obtaining the trust token.
            </summary>
            <param name="service">The service associated with the operation.</param>
            <param name="error">Indicates which error occured.</param>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.Service.OtpWrapper">
            <summary>
            Although the otp command doesn't actually send anything to the SG, it is included in these calls
            so that we can keep the logging centralised.
            This wrapper should, however, never be passed onto the call manager.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.OtpWrapper.OnSuccess">
            <summary>
            The Otp must be set before making this call
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.Service.ServiceCall.Send">
            <summary>
            Used to perform the actual send to the SG
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Sdk.Service.ServiceCall.IsRegistrationRequired">
            <summary>
            Used to control error checks which are automated in ServiceCallManager
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Sdk.Service.ServiceCallManager">
            <summary>
            This simple class keeps track of various service calls and implements most of the standard logic applied to each
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.ServiceCallManager.StartCall(Entersekt.Transakt.Sdk.Service.ServiceCall)">
            <summary>
            Used to start the call timer for a particular type of call.
            If a call is already in progress it will wait on that call
            </summary>
            <param name="serviceCall"></param>
            <returns></returns>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.ServiceCallManager.FirstInLine``1">
            <summary>
            Retrieves the last call in progress for the type specified.
            This is meant to be used for calls which do not allow duplicates as it will only return a maximum of one instance.
            </summary>
            <typeparam name="T">Some subtype of ServiceEvent</typeparam>
            <returns>A ServiceEvent type for the call in progress if one exists, else null</returns>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.ServiceCallManager.AuthInProgress(System.String)">
            <summary>
            Since we allow duplicate concurrent auth calls, this method is used to retrieve a specific one.
            </summary>
            <param name="messageId">Message ID of the auth call we wish to retrieve</param>
            <returns>The appropriate AuthReturnWrapper if one is found, else null</returns>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.TransaktService.ConnectAndAwaitData">
            <summary>
            Connect and wait for all service data to be transferred.
            </summary>
            <returns>A boolean indicating if the operation was successful.</returns>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.TransaktService.SendAuthAnswer(Entersekt.Transakt.Sdk.Helpers.AuthInternal,Entersekt.Transakt.Sdk.Service.IAuthAnswerCallback)">
            <summary>
            Delegate some work to the Service object, which has what we need to do this send.
            Note: make sure all error checking is done before calling this method
            </summary>
            <param name="auth">auth object with our internal properties</param>
            <param name="authAnswerCallback">Supplied callback object</param>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.TransaktService.SendAuthAnswerError(Entersekt.Transakt.Sdk.Helpers.AuthInternal,System.Int32,System.String)">
            <summary>
            Delegate some work to the Service object, which has what we need to do this send.
            </summary>
            <param name="authInternal">auth object with our internal properties</param>
            <param name="errorCode">Error code</param>
            <param name="errorMessage">Error message</param>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Service.TrustTokenWrapper.OnSuccess">
            <summary>
            The trust token must be set before making this call
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.TransaktSdkImpl.Entersekt#Transakt#Sdk#ITransaktSdkInternal#ServiceInfo(System.String)">
            <summary>
            This method retrieves service info from the Message Router. Failure to retrieve info returns null.
            This method should be thread safe and able to handle concurrent calls for different and duplicate services.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.TransaktSdkImpl.GetOrCreateServiceHandler(System.String)">
            <summary>
            This method returns a service handler for the desired service.
            If we don't have service info stored locally it is requested, but not waited for.
            </summary>
            <param name="serviceId">Service Id</param>
            <returns>TransaktService</returns>
        </member>
        <member name="M:Entersekt.Transakt.Sdk.Storage.OtpParamsManager.AdvanceMovingFactor">
            <summary>
            Use this method to safely advance the moving factor on the current OTP parameters. This method will not error or update null parameters.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Connections.NetworkHelper">
            <summary>
            The implementation of this class is essentially static
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Connections.NetworkHelper.GetConnectionGeneration">
            <summary>
            Detect the current connection type
            </summary>
            <returns>2 for 2G, 3 for 3G, 4 for 4G 100 for WiFi 0 for unknown or not connected</returns>
        </member>
        <member name="E:Entersekt.Transakt.Connections.IConnection.Error">
            <summary>
            This event is triggered for any errors that occur in the connection
            </summary>
        </member>
        <member name="E:Entersekt.Transakt.Connections.IConnection.Received">
            <summary>
            This event is triggered when a new data frame is received. The event argument is the data frame
            </summary>
        </member>
        <member name="E:Entersekt.Transakt.Connections.IConnection.StateChanged">
            <summary>
            This event is triggered when a state change occurs. The event argument is the new state
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Connections.KeepAliveConnection.RestartTimer(System.Action{System.Int64},System.Int32)">
            <summary>
            This method is used to restart the timer, pointing it at a specific callback,
            with the interval associated with that callback. eg. RestartTimer(WatchdogIntervalElapsed, WatchdogInterval)
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Connections.SdkConnection.InnerConnection_ConnectionStateChanged(System.Object,Entersekt.Transakt.Connections.ConnectionStates)">
            <summary>
            This method handles changes in state from the base connection.
            Notifications of state change to the next level should primarily originate in this method.
            All logic should switch based on the state changes that this event triggers on.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Connections.SdkConnection.NetworkStatusChanged(System.Object,Entersekt.Transakt.Connections.NetworkStatusChangedEventArgs)">
            <summary>
            This method handles changes in network interfaces and is used to co-ordinate connect/disconnects when this happens.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.HandsetContext.Status.CustomError(System.Int32,System.String)">
            <summary>
            Not to be used liberally!
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.HandsetContext.ContextErrors.QueryNotSupported">
            <summary>
             Debug: The Query item is not recognized by the SDK
             </summary>
        </member>
        <member name="F:Entersekt.Transakt.HandsetContext.ContextErrors.QueryParamNotSupported">
            <summary>
             Debug: The parameter of the Query is not supported
             </summary>
        </member>
        <member name="F:Entersekt.Transakt.HandsetContext.ContextErrors.ServiceDisabled">
            <summary>
             Warning: The service required for accessing this data is disabled
             </summary>
        </member>
        <member name="F:Entersekt.Transakt.HandsetContext.ContextErrors.PermissionDenied">
            <summary>
             Warning: The App needs to request permission to acces this data
             </summary>
        </member>
        <member name="F:Entersekt.Transakt.HandsetContext.ContextErrors.PermissionServiceDisabled">
            <summary>
             Warning: Permission/Service Disabled
             </summary>
        </member>
        <member name="F:Entersekt.Transakt.HandsetContext.ContextErrors.Generic">
            <summary>
             Error: An unrecoverable Error Occured
             </summary>
        </member>
        <member name="F:Entersekt.Transakt.HandsetContext.ContextErrors.InvalidParameterType">
            <summary>
             Error: a Value could not be Parsed, thus an invalid type for input parameter.
             </summary>
        </member>
        <member name="F:Entersekt.Transakt.HandsetContext.ContextErrors.NotSupportedByDevice">
            <summary>
             Error: The device will never support providing this data
             </summary>
        </member>
        <member name="F:Entersekt.Transakt.HandsetContext.ContextErrors.TimeOut">
            <summary>
             Error: Retrieving Context Data took too long, causing a timeout
             </summary>
        </member>
        <member name="T:Entersekt.Transakt.ECert.Asn1.X509CertificateEx">
            <summary>
            This extension of the X509Certificate supports certificate chains and other custom attributes.
            Note that this implementation is not intended to contain the root certificate for the chain. 
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.ECert.Asn1.X509CertificateEx.Trusted">
            <summary>
            <list type="bullet">
            <listheader>
            <term>Trust criteria:</term>
            </listheader>
            <item>
            <description>Any leaf certificate is trusted.</description>
            </item>
            <item>
            <description>Parent certificates must be Certificate Authorities and have the KeyCertSign usage extension.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.ECert.Asn1.X509CertificateEx.Validate(Org.BouncyCastle.X509.X509Certificate)">
            <summary>
            Validate that this certificate is issued by the given issuerCert
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.ECert.Asn1.X509CertificateEx.Validate(System.Collections.Generic.IEnumerable{Org.BouncyCastle.X509.X509Certificate})">
            <summary>
            Validate that this certificate is issued by the given issuerCerts
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.ECert.Asn1.X509CertificateEx.ValidateChain">
            <summary>
            Validate that each of the certificates in this chain has a valid parent.
            Note!: this check does not include this certificate's children or the chain root.
            This should be called on a chain leaf certificate and the final trusted root needs to be validated independently.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.ECert.Asn1.X509CertificateEx.GetEncodedChain">
            <summary>
            Return a Der encoded version of this certificate and its parents.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.ECert.KeyParameterExtensions.ExtractAsymmetricKeyParams(System.Byte[])">
            <summary>
            This wrapper method facilitates conversion of private keys in byte array form to key parameters. It accepts both base64 encoded
            and ASN.1 binary encoded byte arrays
            </summary>
            <param name="pvtKey">Private key byte array</param>
            <returns>AsymmetricCipherKeyPair</returns>
        </member>
        <member name="M:Entersekt.Transakt.ECert.KeyParameterExtensions.ToBytesBase64(Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair)">
            <summary>
            This simple extension method adds the ability to transform key parameters into a base64 encoded byte array.
            </summary>
            <param name="keyPair">Private key paramters</param>
            <returns>Byte array with base64 encoded private key, as contained in a PEM</returns>
        </member>
        <member name="M:Entersekt.Transakt.ECert.IO.FramedStreamConnection.#ctor(Entersekt.Net.IO.IStreamConnection)">
            <summary>
            This class is a wrapper which is used on the Router connection only.
            It's only function is to wrapper the connection streams with Framed*Streams.
            The connection that it wraps should be some kind of actual network connection (TcpClient). 
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Storage.CachedProvider`1">
            <summary>
            This class is meant to keep a copy of storage class to provide on subsequent requests.
            The generic parameter should be filled with the type of the implementing class.
            This is used to distinguish the underlying cache.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Storage.CachedProvider`1.CreateStorage``1(System.String)">
            <summary>
            This particular method is writtern with an attempt to minimise the time spent waiting on the lock
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Storage.CachedStorage`1.Entersekt#Transakt#Storage#IStorage{T}#Keys">
            <summary>
            For now, retrieving the full set of keys is not a cached operation and should be used sparingly
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Storage.CertificateFingerprintData.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.ICollection{System.String}})">
            <summary>
            Constructor to use when serializing
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Storage.CertificateFingerprintData.#ctor">
            <summary>
            Constructor to use when deserializing
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Storage.CertificateFingerprintData.WriteString(System.IO.BinaryWriter,System.String)">
            <summary>
            Simple wrapper method to facilitate more complicated writes
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Storage.CertificateFingerprintData.ReadString(System.IO.BinaryReader)">
            <summary>
            Simple wrapper method to facilitate more complicated reads
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Storage.CertificateFingerprintData.WriteStringCollection(System.IO.BinaryWriter,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Simple wrapper method to facilitate more complicated writes
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Storage.CertificateFingerprintData.ReadStringCollection(System.IO.BinaryReader)">
            <summary>
            Simple wrapper method to facilitate more complicated reads
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Storage.EncryptedStorage`1">
            <summary>
            Most of the methods in this type are pass-through wrappers.
            This type automatically wraps and unwraps the provided StorageValue in EncryptedStorageValue
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Storage.EncryptedStorage`1.Entersekt#Transakt#Storage#IStorage{T}#Keys">
            <summary>
            For now, retrieving the full set of keys is not a cached operation and should be used sparingly
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Storage.EncryptedStorageValue`1.GetEncryptionKey(System.String,System.Boolean)">
            <summary>
            Use the store lookup key to create an encryption key.
            This method uses the provided store lookup key to create additional entropy for the encryption key.
            </summary>
            <param name="key">A string store lookup key.</param>
            <param name="forStore">A boolean informing the encryption key generator if it may create key material if needed.
            Typically it should not be allowed to do so if the encryption key is for deserialisation.</param>
            <returns>A 32 byte (256 bit) key to use for symmetric (en/de)cryption of store values.</returns>
        </member>
        <member name="T:Entersekt.Transakt.Storage.IStorage`1">
            <summary>
            This interface is modelled on IDictionary, although somewhat simpler for our needs. All data is indexed with unique strings.
            </summary>
            <typeparam name="T">the type of data to store</typeparam>
        </member>
        <member name="M:Entersekt.Transakt.Storage.IStorage`1.Add(System.String,`0)">
            <summary>
            Add a value to the storage. If a value already exists at that key it is overwritten.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Storage.IStorage`1.TryGetValue(System.String,`0@)">
            <summary>
            Attempt to get a value at a specified key out of storage by deserialisation.
            If a value is not present at the given key the input value is left unchanged.
            This behaviour differs slightly from the standard dictionary implementation
            which returns a default value in its place if nothing is found.
            </summary>
            <param name="key">The string key against which the value is stored.</param>
            <param name="value">An instance to which the stored value can be deserialised.</param>
            <returns>A boolean indicating if the stored value was found and retrieved.</returns>
        </member>
        <member name="T:Entersekt.Transakt.Storage.IWantToBeCached">
            <summary>
            This is a marker interface to allow wrapping IStorageProviders with CachedStorageProvider
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Storage.IWantToBeEncrypted">
            <summary>
            This is a marker interface to allow wrapping IStorageProviders with EncryptedStorageProvider
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Common.AsyncManualResetEvent.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the AsyncManualResetEvent class with a Boolean value indicating whether to set the initial state to signaled.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Common.AsyncManualResetEvent.Set">
            <summary>
            Set the ResetEvent to signalled, allowing execution to continue.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Common.AsyncManualResetEvent.Reset">
            <summary>
            Set the ResetEvent so that execution is awaited.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Json.Gateway.ResultsJsonCreator.WrapWithJson(System.Double)">
            <summary>
            Take a value and convert it to JSON for wrapping as a JSON string.
            We need to do this because all parameters in the result structure are passed as strings.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Json.Gateway.IGatewayRequestData.MinimumSupportedVersion">
            <summary>
            The minimum supported protocol version individual message types
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Json.Gateway.GatewayResponse">
            <summary>
            This is an intermediate class used for extracting data from our JSON messages. We never deserialize directly to
            this class because of the weird naming convention used in the message protocol.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Json.Gateway.GatewayResponse.ToString">
            <summary>
            Returns the original JSON string used to create this response object
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Json.JsonObject.ParseValue(System.String,System.Int32@)">
            <summary>
            Parse a JSON value from the given string, starting at the index provided. The index parameter variable is
            updated to reflect the end position of the value parsed.
            </summary>
            <param name="json">JSON string to parse</param>
            <param name="index">string index at which to begin parsing</param>
            <returns>a JsonObject which reflects the data contained in the JSON string</returns>
            <exception cref="T:Entersekt.Transakt.Json.JsonException"/>
        </member>
        <member name="M:Entersekt.Transakt.Json.JsonObject.FindNextToken(System.String,System.Int32@)">
            <summary>
            Consumes whitespace and returns the next token it finds. The index parameter is updated to give the starting
            index of the token found.
            </summary>
            <param name="json">json string to search in</param>
            <param name="index">string index at which to begin searching</param>
            <returns>the type of token found</returns>
        </member>
        <member name="M:Entersekt.Transakt.Json.JsonTypeSpecification.IsImplementedBy(Entersekt.Transakt.Json.JsonObject)">
            <summary>
            This method confirms the JSON structure provided is a subclass of the specification.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Json.JsonTypeSpecification.IsPartiallyImplementedBy(Entersekt.Transakt.Json.JsonObject)">
            <summary>
            This method confirms there are no type mis-matches between the common members of the JSON structure provided and the specification.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Json.Router.IRouterRequestData">
            <summary>
            This interface is really just a gatekeeper to restrict using classes with our JSON methods. A class must
            implement this if it wants to be considered for serialisation.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Json.Router.RouterResponse">
            <summary>
            This is an intermediate class used for extracting data from our JSON messages.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Json.Router.RouterResponse.ToString">
            <summary>
            Returns the original JSON string used to create this response object
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Json.Router.V1.AuthEvent">
            <summary>
            We reuse the parent class as a kind of Enum to restrict the values entered for the event field.
            </summary>
        </member>
        <member name="P:Entersekt.Transakt.Json.Router.V1.Service.Info">
            <summary>
            This field should only ever be populated by an incoming Json Response
            </summary>
        </member>
        <member name="F:Entersekt.Transakt.Protocol.GenericOutboundHandler.MaximumSupportedVersion">
            <summary>
            The maximum supported protocol version in this implementation
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Protocol.RouterOutboundHandler">
            <summary>
            We should only need one version of the this handler which is always up to date with the latest
            Router comms protocol. The Router should handle backwards compatibility, not the app.
            </summary>
        </member>
        <member name="T:Entersekt.Transakt.Settings.NullHandlingSetting`1">
            <summary>
            This wrapper class can be used to add null handling to an existing setting.
            If a null value is encountered when getting or setting the value, then it is replaced with a specified alternative value.
            </summary>
            <typeparam name="T">Type of the setting value</typeparam>
        </member>
        <member name="M:Entersekt.Transakt.Settings.NullHandlingSetting`1.#ctor(Entersekt.Transakt.Settings.ISetting{`0},`0)">
            <param name="setting">The setting to wrap with null handling</param>
            <param name="valueWhenNull">The value to use when encountering a null</param>
        </member>
        <member name="T:Entersekt.Transakt.Settings.PersistentSetting">
            <summary>
            This implementation is used for persistent settings which can change and should be kept in the local storage of the app.
            </summary>
        </member>
        <member name="M:Entersekt.Transakt.Settings.PersistentSetting.#ctor(System.String,System.String)">
            <summary>
            Create a string setting which is persisted between app instances.
            </summary>
            <param name="key">The key to use in the local store</param>
            <param name="defaultValue">The default value for this setting, if not found in the local store</param>
        </member>
        <member name="T:Entersekt.Transakt.Settings.SetOnceSetting`1">
            <summary>
            This setting implementation holds a static value which can only be set once.
            Attempting to set the value of this setting another time throws an InvalidOperationException
            </summary>
            <typeparam name="T">Type of the setting value</typeparam>
        </member>
        <member name="T:Entersekt.Transakt.Settings.StaticSetting`1">
            <summary>
            This setting implementation holds a static value which can never change.
            Attempting to set the value of this setting throws a NotSupportedException
            </summary>
            <typeparam name="T">Type of the setting value</typeparam>
        </member>
        <member name="M:Entersekt.Transakt.Settings.StaticSetting`1.#ctor(`0)">
            <param name="value">The value of the setting</param>
        </member>
        <member name="T:Entersekt.Transakt.Settings.ValidatedSetting`1">
            <summary>
            This wrapper class can be used to add basic validation to an existing setting.
            If validation fails upon setting a value, a SettingValidationException : ArgumentException is thrown
            </summary>
            <typeparam name="T">Type of the setting value</typeparam>
        </member>
        <member name="M:Entersekt.Transakt.Settings.ValidatedSetting`1.#ctor(Entersekt.Transakt.Settings.ISetting{`0},System.Func{`0,System.Boolean})">
            <param name="setting">The setting to wrap with validation</param>
            <param name="validationFunc">The validation function, which should return true if validation passes and false otherwise</param>
        </member>
        <member name="T:Entersekt.Transakt.Settings.VolatileSetting`1">
            <summary>
            This setting implementation holds a basic variable whose value will not persist if the application is closed
            </summary>
            <typeparam name="T">Type of the setting value</typeparam>
        </member>
        <member name="M:Entersekt.Transakt.Settings.VolatileSetting`1.#ctor(`0)">
            <param name="value">The initial value of the setting</param>
        </member>
        <member name="T:Entersekt.Net.IO.EndianBinaryReader">
            <summary>
            Equivalent of System.IO.BinaryReader, but with either endianness, depending on
            the EndianBitConverter it is constructed with. No data is buffered in the
            reader; the client may seek within the stream at will.
            </summary>
        </member>
        <member name="F:Entersekt.Net.IO.EndianBinaryReader.disposed">
            <summary>
            Whether or not this reader has been disposed yet.
            </summary>
        </member>
        <member name="F:Entersekt.Net.IO.EndianBinaryReader.decoder">
            <summary>
            Decoder to use for string conversions.
            </summary>
        </member>
        <member name="F:Entersekt.Net.IO.EndianBinaryReader.buffer">
            <summary>
            Buffer used for temporary storage before conversion into primitives
            </summary>
        </member>
        <member name="F:Entersekt.Net.IO.EndianBinaryReader.charBuffer">
            <summary>
            Buffer used for temporary storage when reading a single character
            </summary>
        </member>
        <member name="F:Entersekt.Net.IO.EndianBinaryReader.stream">
            <summary>
            Underlying stream used by this reader
            </summary>
        </member>
        <member name="F:Entersekt.Net.IO.EndianBinaryReader.minBytesPerChar">
            <summary>
            Minimum number of bytes used to encode a character
            </summary>
        </member>
        <member name="P:Entersekt.Net.IO.EndianBinaryReader.Encoding">
            <summary>
            The encoding used to read strings
            </summary>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.#ctor(Entersekt.Common.Conversion.EndianBitConverter,System.IO.Stream)">
            <summary>
            Equivalent of System.IO.BinaryWriter, but with either endianness, depending on
            the EndianBitConverter it is constructed with.
            </summary>
            <param name="bitConverter">Converter to use when reading data</param>
            <param name="stream">Stream to read data from</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.#ctor(Entersekt.Common.Conversion.EndianBitConverter,System.IO.Stream,System.Text.Encoding)">
            <summary>
            Constructs a new binary reader with the given bit converter, reading
            to the given stream, using the given encoding.
            </summary>
            <param name="bitConverter">Converter to use when reading data</param>
            <param name="stream">Stream to read data from</param>
            <param name="encoding">Encoding to use when reading character data</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.Close">
            <summary>
            Closes the reader, including the underlying stream..
            </summary>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.Seek(System.Int32,System.IO.SeekOrigin)">
            <summary>
            Seeks within the stream.
            </summary>
            <param name="offset">Offset to seek to.</param>
            <param name="origin">Origin of seek operation.</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.ReadByte">
            <summary>
            Reads a single byte from the stream.
            </summary>
            <returns>The byte read</returns>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.ReadSByte">
            <summary>
            Reads a single signed byte from the stream.
            </summary>
            <returns>The byte read</returns>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.ReadBoolean">
            <summary>
            Reads a boolean from the stream. 1 byte is read.
            </summary>
            <returns>The boolean read</returns>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.ReadInt16">
            <summary>
            Reads a 16-bit signed integer from the stream, using the bit converter
            for this reader. 2 bytes are read.
            </summary>
            <returns>The 16-bit integer read</returns>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.ReadInt32">
            <summary>
            Reads a 32-bit signed integer from the stream, using the bit converter
            for this reader. 4 bytes are read.
            </summary>
            <returns>The 32-bit integer read</returns>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.ReadInt64">
            <summary>
            Reads a 64-bit signed integer from the stream, using the bit converter
            for this reader. 8 bytes are read.
            </summary>
            <returns>The 64-bit integer read</returns>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.ReadUInt16">
            <summary>
            Reads a 16-bit unsigned integer from the stream, using the bit converter
            for this reader. 2 bytes are read.
            </summary>
            <returns>The 16-bit unsigned integer read</returns>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.ReadUInt32">
            <summary>
            Reads a 32-bit unsigned integer from the stream, using the bit converter
            for this reader. 4 bytes are read.
            </summary>
            <returns>The 32-bit unsigned integer read</returns>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.ReadUInt64">
            <summary>
            Reads a 64-bit unsigned integer from the stream, using the bit converter
            for this reader. 8 bytes are read.
            </summary>
            <returns>The 64-bit unsigned integer read</returns>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.ReadSingle">
            <summary>
            Reads a single-precision floating-point value from the stream, using the bit converter
            for this reader. 4 bytes are read.
            </summary>
            <returns>The floating point value read</returns>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.ReadDouble">
            <summary>
            Reads a double-precision floating-point value from the stream, using the bit converter
            for this reader. 8 bytes are read.
            </summary>
            <returns>The floating point value read</returns>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.ReadDecimal">
            <summary>
            Reads a decimal value from the stream, using the bit converter
            for this reader. 16 bytes are read.
            </summary>
            <returns>The decimal value read</returns>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.Read(System.Char[],System.Int32,System.Int32)">
            <summary>
            Reads the specified number of characters into the given buffer, starting at
            the given index.
            </summary>
            <param name="data">The buffer to copy data into</param>
            <param name="index">The first index to copy data into</param>
            <param name="count">The number of characters to read</param>
            <returns>The number of characters actually read. This will only be less than
            the requested number of characters if the end of the stream is reached.
            </returns>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the specified number of bytes into the given buffer, starting at
            the given index.
            </summary>
            <param name="buffer">The buffer to copy data into</param>
            <param name="index">The first index to copy data into</param>
            <param name="count">The number of bytes to read</param>
            <returns>The number of bytes actually read. This will only be less than
            the requested number of bytes if the end of the stream is reached.
            </returns>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.ReadBytes(System.Int32)">
            <summary>
            Reads the specified number of bytes, returning them in a new byte array.
            If not enough bytes are available before the end of the stream, this
            method will return what is available.
            </summary>
            <param name="count">The number of bytes to read</param>
            <returns>The bytes read</returns>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.ReadBytesOrThrow(System.Int32)">
            <summary>
            Reads the specified number of bytes, returning them in a new byte array.
            If not enough bytes are available before the end of the stream, this
            method will throw an IOException.
            </summary>
            <param name="count">The number of bytes to read</param>
            <returns>The bytes read</returns>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.Read7BitEncodedInt">
            <summary>
            Reads a 7-bit encoded integer from the stream. This is stored with the least significant
            information first, with 7 bits of information per byte of value, and the top
            bit as a continuation flag. This method is not affected by the endianness
            of the bit converter.
            </summary>
            <returns>The 7-bit encoded integer read from the stream.</returns>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.ReadBigEndian7BitEncodedInt">
            <summary>
            Reads a 7-bit encoded integer from the stream. This is stored with the most significant
            information first, with 7 bits of information per byte of value, and the top
            bit as a continuation flag. This method is not affected by the endianness
            of the bit converter.
            </summary>
            <returns>The 7-bit encoded integer read from the stream.</returns>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.ReadString">
            <summary>
            Reads a length-prefixed string from the stream, using the encoding for this reader.
            A 7-bit encoded integer is first read, which specifies the number of bytes 
            to read from the stream. These bytes are then converted into a string with
            the encoding for this reader.
            </summary>
            <returns>The string read from the stream.</returns>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.CheckDisposed">
            <summary>
            Checks whether or not the reader has been disposed, throwing an exception if so.
            </summary>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.ReadInternal(System.Byte[],System.Int32)">
            <summary>
            Reads the given number of bytes from the stream, throwing an exception
            if they can't all be read.
            </summary>
            <param name="data">Buffer to read into</param>
            <param name="size">Number of bytes to read</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.TryReadInternal(System.Byte[],System.Int32)">
            <summary>
            Reads the given number of bytes from the stream if possible, returning
            the number of bytes actually read, which may be less than requested if
            (and only if) the end of the stream is reached.
            </summary>
            <param name="data">Buffer to read into</param>
            <param name="size">Number of bytes to read</param>
            <returns>Number of bytes actually read</returns>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryReader.Dispose">
            <summary>
            Disposes of the underlying stream.
            </summary>
        </member>
        <member name="T:Entersekt.Net.IO.EndianBinaryWriter">
            <summary>
            Equivalent of System.IO.BinaryWriter, but with either endianness, depending on
            the EndianBitConverter it is constructed with.
            </summary>
        </member>
        <member name="F:Entersekt.Net.IO.EndianBinaryWriter.disposed">
            <summary>
            Whether or not this writer has been disposed yet.
            </summary>
        </member>
        <member name="F:Entersekt.Net.IO.EndianBinaryWriter.buffer">
            <summary>
            Buffer used for temporary storage during conversion from primitives
            </summary>
        </member>
        <member name="F:Entersekt.Net.IO.EndianBinaryWriter.charBuffer">
            <summary>
            Buffer used for Write(char)
            </summary>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.#ctor(Entersekt.Common.Conversion.EndianBitConverter,System.IO.Stream)">
            <summary>
            Constructs a new binary writer with the given bit converter, writing
            to the given stream, using UTF-8 encoding.
            </summary>
            <param name="bitConverter">Converter to use when writing data</param>
            <param name="stream">Stream to write data to</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.#ctor(Entersekt.Common.Conversion.EndianBitConverter,System.IO.Stream,System.Text.Encoding)">
            <summary>
            Constructs a new binary writer with the given bit converter, writing
            to the given stream, using the given encoding.
            </summary>
            <param name="bitConverter">Converter to use when writing data</param>
            <param name="stream">Stream to write data to</param>
            <param name="encoding">Encoding to use when writing character data</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.Flush">
            <summary>
            Flushes the underlying stream.
            </summary>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.WriteBoolean(System.Boolean)">
            <summary>
            Writes a boolean value to the stream. 1 byte is written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.WriteInt16(System.Int16)">
            <summary>
            Writes a 16-bit signed integer to the stream, using the bit converter
            for this writer. 2 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.WriteInt32(System.Int32)">
            <summary>
            Writes a 32-bit signed integer to the stream, using the bit converter
            for this writer. 4 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.WriteInt64(System.Int64)">
            <summary>
            Writes a 64-bit signed integer to the stream, using the bit converter
            for this writer. 8 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.WriteUInt16(System.UInt16)">
            <summary>
            Writes a 16-bit unsigned integer to the stream, using the bit converter
            for this writer. 2 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.WriteUInt32(System.UInt32)">
            <summary>
            Writes a 32-bit unsigned integer to the stream, using the bit converter
            for this writer. 4 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.WriteUInt64(System.UInt64)">
            <summary>
            Writes a 64-bit unsigned integer to the stream, using the bit converter
            for this writer. 8 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.WriteSingle(System.Single)">
            <summary>
            Writes a single-precision floating-point value to the stream, using the bit converter
            for this writer. 4 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.WriteDouble(System.Double)">
            <summary>
            Writes a double-precision floating-point value to the stream, using the bit converter
            for this writer. 8 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.Write(System.Decimal)">
            <summary>
            Writes a decimal value to the stream, using the bit converter for this writer.
            16 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.WriteByte(System.Byte)">
            <summary>
            Writes a signed byte to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.Write(System.SByte)">
            <summary>
            Writes an unsigned byte to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.WriteBytes(System.Byte[])">
            <summary>
            Writes an array of bytes to the stream.
            </summary>
            <param name="value">The values to write</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a portion of an array of bytes to the stream.
            </summary>
            <param name="value">An array containing the bytes to write</param>
            <param name="offset">The index of the first byte to write within the array</param>
            <param name="count">The number of bytes to write</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.WriteChar(System.Char)">
            <summary>
            Writes a single character to the stream, using the encoding for this writer.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.Write(System.Char[])">
            <summary>
            Writes an array of characters to the stream, using the encoding for this writer.
            </summary>
            <param name="value">An array containing the characters to write</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.Write(System.String)">
            <summary>
            Writes a string to the stream, using the encoding for this writer.
            </summary>
            <param name="value">The value to write. Must not be null.</param>
            <exception cref="T:System.ArgumentNullException">value is null</exception>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.Write7BitEncodedInt(System.Int32)">
            <summary>
            Writes a 7-bit encoded integer from the stream. This is stored with the least significant
            information first, with 7 bits of information per byte of value, and the top
            bit as a continuation flag.
            </summary>
            <param name="value">The 7-bit encoded integer to write to the stream</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.CheckDisposed">
            <summary>
            Checks whether or not the writer has been disposed, throwing an exception if so.
            </summary>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.WriteInternal(System.Byte[],System.Int32)">
            <summary>
            Writes the specified number of bytes from the start of the given byte array,
            after checking whether or not the writer has been disposed.
            </summary>
            <param name="bytes">The array of bytes to write from</param>
            <param name="length">The number of bytes to write</param>
        </member>
        <member name="M:Entersekt.Net.IO.EndianBinaryWriter.Dispose">
            <summary>
            Disposes of the underlying stream.
            </summary>
        </member>
        <member name="M:Entersekt.BinaryProtocol.Protocol.IProtocol.ProcessFrame(System.Object)">
            <summary>
            Process an incoming message frame
            </summary>
            <param name="frame">The incoming message frame</param>
            <returns>A outgoing message frame that will be queue to be sent to server</returns>
        </member>
        <member name="F:Entersekt.BinaryProtocol.Protocol.ProtocolBase.EC_NONE">
            Error codes
        </member>
        <member name="F:Entersekt.BinaryProtocol.Protocol.ProtocolBase.RC_OK">
            Response Codes
        </member>
        <member name="F:Entersekt.BinaryProtocol.Protocol.ProtocolBase.RC_SERVER_MAINTENANCE">
            Redirect response: Server is going down for maintenance.
        </member>
        <member name="F:Entersekt.BinaryProtocol.Protocol.ProtocolBase.RC_SERVER_OVERLOADED">
            Redirect response: Server is overloaded.
        </member>
        <member name="F:Entersekt.BinaryProtocol.Protocol.ProtocolBase.LITCHI_HELLO_REQUEST">
            System command: Hello - first packet from client.
              String    Version - Current version running on the client
        </member>
        <member name="F:Entersekt.BinaryProtocol.Protocol.ProtocolBase.LITCHI_HELLO_RESPONSE">
            System command: Hello response - sent in response to hello packet.
              Boolean      Update - is there an updated available.
              UnsingedByte Packets - Number of packets in payload.
        </member>
        <member name="F:Entersekt.BinaryProtocol.Protocol.ProtocolBase.KEEP_ALIVE">
            System command: Keep alive packet
              (none)    (none)
        </member>
        <member name="F:Entersekt.BinaryProtocol.Protocol.ProtocolBase.CLOSE_NOTIFY">
            System command: Close notify
              int   closeCode - the reason code for closure. (None defined at the moment.)
                          0: Ok
                          1: ....
        </member>
        <member name="F:Entersekt.BinaryProtocol.Protocol.ProtocolBase.FORCED_CLOSE">
            System command: Forced close
              int   CloseCode - the reason code for closure. (None defined at the moment.)
                          0 Ok
                          1 ...
              String    CloseMsg - the reason message for closure.
        </member>
        <member name="F:Entersekt.BinaryProtocol.Protocol.ProtocolBase.REDIRECT">
            System command: Redirect
              int   redirectCode - the reason code for the redirect.
                          0 Unknown
                          1 Server is going down for maintenance.
                          2 Server is overloaded.
              String    redirectMessage - the reason message for the redirect.
              String    redirectUrl - the redirect host URL.
        </member>
        <member name="F:Entersekt.BinaryProtocol.Protocol.ProtocolBase.REDIRECT_ACK">
            System command: Redirect acknowledgment
              int   redirectResponseCode - the redirect response code.
                          0 Ok
                          1 Unknown error
                          2 Incorrect number of fields.
                          3 redirect URL is not valid.
        </member>
        <member name="T:Entersekt.Common.Conversion.BigEndianBitConverter">
            <summary>
            Implementation of EndianBitConverter which converts to/from big-endian
            byte arrays.
            </summary>
        </member>
        <member name="M:Entersekt.Common.Conversion.BigEndianBitConverter.IsLittleEndian">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
            <remarks>
            Different computer architectures store data using different byte orders. "Big-endian"
            means the most significant byte is on the left end of a word. "Little-endian" means the 
            most significant byte is on the right end of a word.
            </remarks>
            <returns>true if this converter is little-endian, false otherwise.</returns>
        </member>
        <member name="P:Entersekt.Common.Conversion.BigEndianBitConverter.Endianness">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
        </member>
        <member name="M:Entersekt.Common.Conversion.BigEndianBitConverter.CopyBytesImpl(System.Int64,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the specified number of bytes from value to buffer, starting at index.
            </summary>
            <param name="value">The value to copy</param>
            <param name="bytes">The number of bytes to copy</param>
            <param name="buffer">The buffer to copy the bytes into</param>
            <param name="index">The index to start at</param>
        </member>
        <member name="M:Entersekt.Common.Conversion.BigEndianBitConverter.FromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns a value built from the specified number of bytes from the given buffer,
            starting at index.
            </summary>
            <param name="buffer">The data in byte array format</param>
            <param name="startIndex">The first index to use</param>
            <param name="bytesToConvert">The number of bytes to use</param>
            <returns>The value built from the given bytes</returns>
        </member>
        <member name="T:Entersekt.Common.Conversion.DoubleConverter">
            <summary>
            A class to allow the conversion of doubles to string representations of
            their exact decimal values. The implementation aims for readability over
            efficiency.
            </summary>
        </member>
        <member name="M:Entersekt.Common.Conversion.DoubleConverter.ToExactString(System.Double)">
            <summary>
            Converts the given double to a string representation of its
            exact decimal value.
            </summary>
            <param name="d">The double to convert.</param>
            <returns>A string representation of the double's exact decimal value.</returns>
        </member>
        <member name="T:Entersekt.Common.Conversion.DoubleConverter.ArbitraryDecimal">
            <summary>
            Private class used for manipulating sequences of decimal digits.
            </summary>
        </member>
        <member name="F:Entersekt.Common.Conversion.DoubleConverter.ArbitraryDecimal.digits">
            <summary>Digits in the decimal expansion, one byte per digit</summary>
        </member>
        <member name="F:Entersekt.Common.Conversion.DoubleConverter.ArbitraryDecimal.decimalPoint">
            <summary> 
            How many digits are *after* the decimal point
            </summary>
        </member>
        <member name="M:Entersekt.Common.Conversion.DoubleConverter.ArbitraryDecimal.#ctor(System.Int64)">
            <summary> 
            Constructs an arbitrary decimal expansion from the given long.
            The long must not be negative.
            </summary>
        </member>
        <member name="M:Entersekt.Common.Conversion.DoubleConverter.ArbitraryDecimal.MultiplyBy(System.Int32)">
            <summary>
            Multiplies the current expansion by the given amount, which should
            only be 2 or 5.
            </summary>
        </member>
        <member name="M:Entersekt.Common.Conversion.DoubleConverter.ArbitraryDecimal.Shift(System.Int32)">
            <summary>
            Shifts the decimal point; a negative value makes
            the decimal expansion bigger (as fewer digits come after the
            decimal place) and a positive value makes the decimal
            expansion smaller.
            </summary>
        </member>
        <member name="M:Entersekt.Common.Conversion.DoubleConverter.ArbitraryDecimal.Normalize">
            <summary>
            Removes leading/trailing zeroes from the expansion.
            </summary>
        </member>
        <member name="M:Entersekt.Common.Conversion.DoubleConverter.ArbitraryDecimal.ToString">
            <summary>
            Converts the value to a proper decimal string representation.
            </summary>
        </member>
        <member name="T:Entersekt.Common.Conversion.EndianBitConverter">
            <summary>
            Equivalent of System.BitConverter, but with either endianness.
            </summary>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.IsLittleEndian">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
            <remarks>
            Different computer architectures store data using different byte orders. "Big-endian"
            means the most significant byte is on the left end of a word. "Little-endian" means the 
            most significant byte is on the right end of a word.
            </remarks>
            <returns>true if this converter is little-endian, false otherwise.</returns>
        </member>
        <member name="P:Entersekt.Common.Conversion.EndianBitConverter.Endianness">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
        </member>
        <member name="P:Entersekt.Common.Conversion.EndianBitConverter.Little">
            <summary>
            Returns a little-endian bit converter instance. The same instance is
            always returned.
            </summary>
        </member>
        <member name="P:Entersekt.Common.Conversion.EndianBitConverter.Big">
            <summary>
            Returns a big-endian bit converter instance. The same instance is
            always returned.
            </summary>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.DoubleToInt64Bits(System.Double)">
            <summary>
            Converts the specified double-precision floating point number to a 
            64-bit signed integer. Note: the endianness of this converter does not
            affect the returned value.
            </summary>
            <param name="value">The number to convert. </param>
            <returns>A 64-bit signed integer whose value is equivalent to value.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.Int64BitsToDouble(System.Int64)">
            <summary>
            Converts the specified 64-bit signed integer to a double-precision 
            floating point number. Note: the endianness of this converter does not
            affect the returned value.
            </summary>
            <param name="value">The number to convert. </param>
            <returns>A double-precision floating point number whose value is equivalent to value.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.SingleToInt32Bits(System.Single)">
            <summary>
            Converts the specified single-precision floating point number to a 
            32-bit signed integer. Note: the endianness of this converter does not
            affect the returned value.
            </summary>
            <param name="value">The number to convert. </param>
            <returns>A 32-bit signed integer whose value is equivalent to value.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.Int32BitsToSingle(System.Int32)">
            <summary>
            Converts the specified 32-bit signed integer to a single-precision floating point 
            number. Note: the endianness of this converter does not
            affect the returned value.
            </summary>
            <param name="value">The number to convert. </param>
            <returns>A single-precision floating point number whose value is equivalent to value.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.ToBoolean(System.Byte[],System.Int32)">
            <summary>
            Returns a Boolean value converted from one byte at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>true if the byte at startIndex in value is nonzero; otherwise, false.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.ToChar(System.Byte[],System.Int32)">
            <summary>
            Returns a Unicode character converted from two bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A character formed by two bytes beginning at startIndex.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.ToDouble(System.Byte[],System.Int32)">
            <summary>
            Returns a double-precision floating point number converted from eight bytes 
            at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A double precision floating point number formed by eight bytes beginning at startIndex.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.ToSingle(System.Byte[],System.Int32)">
            <summary>
            Returns a single-precision floating point number converted from four bytes 
            at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A single precision floating point number formed by four bytes beginning at startIndex.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.ToInt16(System.Byte[],System.Int32)">
            <summary>
            Returns a 16-bit signed integer converted from two bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 16-bit signed integer formed by two bytes beginning at startIndex.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.ToInt32(System.Byte[],System.Int32)">
            <summary>
            Returns a 32-bit signed integer converted from four bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 32-bit signed integer formed by four bytes beginning at startIndex.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.ToInt64(System.Byte[],System.Int32)">
            <summary>
            Returns a 64-bit signed integer converted from eight bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 64-bit signed integer formed by eight bytes beginning at startIndex.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.ToUInt16(System.Byte[],System.Int32)">
            <summary>
            Returns a 16-bit unsigned integer converted from two bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 16-bit unsigned integer formed by two bytes beginning at startIndex.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.ToUInt32(System.Byte[],System.Int32)">
            <summary>
            Returns a 32-bit unsigned integer converted from four bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 32-bit unsigned integer formed by four bytes beginning at startIndex.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.ToUInt64(System.Byte[],System.Int32)">
            <summary>
            Returns a 64-bit unsigned integer converted from eight bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 64-bit unsigned integer formed by eight bytes beginning at startIndex.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.CheckByteArgument(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Checks the given argument for validity.
            </summary>
            <param name="value">The byte array passed in</param>
            <param name="startIndex">The start index passed in</param>
            <param name="bytesRequired">The number of bytes required</param>
            <exception cref="T:System.ArgumentNullException">value is a null reference</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            startIndex is less than zero or greater than the length of value minus bytesRequired.
            </exception>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.CheckedFromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Checks the arguments for validity before calling FromBytes
            (which can therefore assume the arguments are valid).
            </summary>
            <param name="value">The bytes to convert after checking</param>
            <param name="startIndex">The index of the first byte to convert</param>
            <param name="bytesToConvert">The number of bytes to convert</param>
            <returns></returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.FromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert the given number of bytes from the given array, from the given start
            position, into a long, using the bytes as the least significant part of the long.
            By the time this is called, the arguments have been checked for validity.
            </summary>
            <param name="value">The bytes to convert</param>
            <param name="startIndex">The index of the first byte to convert</param>
            <param name="bytesToConvert">The number of bytes to use in the conversion</param>
            <returns>The converted number</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.ToString(System.Byte[])">
            <summary>
            Returns a String converted from the elements of a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <remarks>All the elements of value are converted.</remarks>
            <returns>
            A String of hexadecimal pairs separated by hyphens, where each pair 
            represents the corresponding element in value; for example, "7F-2C-4A".
            </returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.ToString(System.Byte[],System.Int32)">
            <summary>
            Returns a String converted from the elements of a byte array starting at a specified array position.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <remarks>The elements from array position startIndex to the end of the array are converted.</remarks>
            <returns>
            A String of hexadecimal pairs separated by hyphens, where each pair 
            represents the corresponding element in value; for example, "7F-2C-4A".
            </returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.ToString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns a String converted from a specified number of bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <param name="length">The number of bytes to convert.</param>
            <remarks>The length elements from array position startIndex are converted.</remarks>
            <returns>
            A String of hexadecimal pairs separated by hyphens, where each pair 
            represents the corresponding element in value; for example, "7F-2C-4A".
            </returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.ToDecimal(System.Byte[],System.Int32)">
            <summary>
            Returns a decimal value converted from sixteen bytes 
            at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A decimal  formed by sixteen bytes beginning at startIndex.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.GetBytes(System.Decimal)">
            <summary>
            Returns the specified decimal value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 16.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.CopyBytes(System.Decimal,System.Byte[],System.Int32)">
            <summary>
            Copies the specified decimal value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">A character to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.GetBytes(System.Int64,System.Int32)">
            <summary>
            Returns an array with the given number of bytes formed
            from the least significant bytes of the specified value.
            This is used to implement the other GetBytes methods.
            </summary>
            <param name="value">The value to get bytes for</param>
            <param name="bytes">The number of significant bytes to return</param>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.GetBytes(System.Boolean)">
            <summary>
            Returns the specified Boolean value as an array of bytes.
            </summary>
            <param name="value">A Boolean value.</param>
            <returns>An array of bytes with length 1.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.GetBytes(System.Char)">
            <summary>
            Returns the specified Unicode character value as an array of bytes.
            </summary>
            <param name="value">A character to convert.</param>
            <returns>An array of bytes with length 2.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.GetBytes(System.Double)">
            <summary>
            Returns the specified double-precision floating point value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 8.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.GetBytes(System.Int16)">
            <summary>
            Returns the specified 16-bit signed integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 2.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.GetBytes(System.Int32)">
            <summary>
            Returns the specified 32-bit signed integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 4.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.GetBytes(System.Int64)">
            <summary>
            Returns the specified 64-bit signed integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 8.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.GetBytes(System.Single)">
            <summary>
            Returns the specified single-precision floating point value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 4.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.GetBytes(System.UInt16)">
            <summary>
            Returns the specified 16-bit unsigned integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 2.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.GetBytes(System.UInt32)">
            <summary>
            Returns the specified 32-bit unsigned integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 4.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.GetBytes(System.UInt64)">
            <summary>
            Returns the specified 64-bit unsigned integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 8.</returns>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.CopyBytes(System.Int64,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the given number of bytes from the least-specific
            end of the specified value into the specified byte array, beginning
            at the specified index.
            This is used to implement the other CopyBytes methods.
            </summary>
            <param name="value">The value to copy bytes for</param>
            <param name="bytes">The number of significant bytes to copy</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.CopyBytesImpl(System.Int64,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the given number of bytes from the least-specific
            end of the specified value into the specified byte array, beginning
            at the specified index.
            This must be implemented in concrete derived classes, but the implementation
            may assume that the value will fit into the buffer.
            </summary>
            <param name="value">The value to copy bytes for</param>
            <param name="bytes">The number of significant bytes to copy</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.CopyBytes(System.Boolean,System.Byte[],System.Int32)">
            <summary>
            Copies the specified Boolean value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">A Boolean value.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.CopyBytes(System.Char,System.Byte[],System.Int32)">
            <summary>
            Copies the specified Unicode character value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">A character to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.CopyBytes(System.Double,System.Byte[],System.Int32)">
            <summary>
            Copies the specified double-precision floating point value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.CopyBytes(System.Int16,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 16-bit signed integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.CopyBytes(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 32-bit signed integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.CopyBytes(System.Int64,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 64-bit signed integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.CopyBytes(System.Single,System.Byte[],System.Int32)">
            <summary>
            Copies the specified single-precision floating point value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.CopyBytes(System.UInt16,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 16-bit unsigned integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.CopyBytes(System.UInt32,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 32-bit unsigned integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.CopyBytes(System.UInt64,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 64-bit unsigned integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="T:Entersekt.Common.Conversion.EndianBitConverter.Int32SingleUnion">
            <summary>
            Union used solely for the equivalent of DoubleToInt64Bits and vice versa.
            </summary>
        </member>
        <member name="F:Entersekt.Common.Conversion.EndianBitConverter.Int32SingleUnion.i">
            <summary>
            Int32 version of the value.
            </summary>
        </member>
        <member name="F:Entersekt.Common.Conversion.EndianBitConverter.Int32SingleUnion.f">
            <summary>
            Single version of the value.
            </summary>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.Int32SingleUnion.#ctor(System.Int32)">
            <summary>
            Creates an instance representing the given integer.
            </summary>
            <param name="i">The integer value of the new instance.</param>
        </member>
        <member name="M:Entersekt.Common.Conversion.EndianBitConverter.Int32SingleUnion.#ctor(System.Single)">
            <summary>
            Creates an instance representing the given floating point number.
            </summary>
            <param name="f">The floating point value of the new instance.</param>
        </member>
        <member name="P:Entersekt.Common.Conversion.EndianBitConverter.Int32SingleUnion.AsInt32">
            <summary>
            Returns the value of the instance as an integer.
            </summary>
        </member>
        <member name="P:Entersekt.Common.Conversion.EndianBitConverter.Int32SingleUnion.AsSingle">
            <summary>
            Returns the value of the instance as a floating point number.
            </summary>
        </member>
        <member name="T:Entersekt.Common.Conversion.Endianness">
            <summary>
            Endianness of a converter
            </summary>
        </member>
        <member name="F:Entersekt.Common.Conversion.Endianness.LittleEndian">
            <summary>
            Little endian - least significant byte first
            </summary>
        </member>
        <member name="F:Entersekt.Common.Conversion.Endianness.BigEndian">
            <summary>
            Big endian - most significant byte first
            </summary>
        </member>
        <member name="T:Entersekt.Common.Conversion.LittleEndianBitConverter">
            <summary>
            Implementation of EndianBitConverter which converts to/from little-endian
            byte arrays.
            </summary>
        </member>
        <member name="M:Entersekt.Common.Conversion.LittleEndianBitConverter.IsLittleEndian">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
            <remarks>
            Different computer architectures store data using different byte orders. "Big-endian"
            means the most significant byte is on the left end of a word. "Little-endian" means the 
            most significant byte is on the right end of a word.
            </remarks>
            <returns>true if this converter is little-endian, false otherwise.</returns>
        </member>
        <member name="P:Entersekt.Common.Conversion.LittleEndianBitConverter.Endianness">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
        </member>
        <member name="M:Entersekt.Common.Conversion.LittleEndianBitConverter.CopyBytesImpl(System.Int64,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the specified number of bytes from value to buffer, starting at index.
            </summary>
            <param name="value">The value to copy</param>
            <param name="bytes">The number of bytes to copy</param>
            <param name="buffer">The buffer to copy the bytes into</param>
            <param name="index">The index to start at</param>
        </member>
        <member name="M:Entersekt.Common.Conversion.LittleEndianBitConverter.FromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns a value built from the specified number of bytes from the given buffer,
            starting at index.
            </summary>
            <param name="buffer">The data in byte array format</param>
            <param name="startIndex">The first index to use</param>
            <param name="bytesToConvert">The number of bytes to use</param>
            <returns>The value built from the given bytes</returns>
        </member>
        <member name="M:Entersekt.Common.Utils.StringUtils.HexStringToByteArray(System.String)">
            <summary>
            This extension method converts a string of hex characters to a byte array.
            The array will contain exactly half the number of bytes as hex characters (rounded up),
            with each byte containing the value of subsequent hex pairs.
            </summary>
            <param name="value">hex string</param>
            <returns>a byte array</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Encodable.GetDerEncoded">
             Return the DER encoding of the object, null if the DER encoding can not be made.
            
             @return a DER byte array, null otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Asn1InputStream">
            a general purpose ASN.1 decoder - note: this class differs from the
            others in that it returns null after it has read the last object in
            the stream. If an ASN.1 Null is encountered a Der/BER Null object is
            returned.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1InputStream.#ctor(System.IO.Stream,System.Int32)">
             Create an ASN1InputStream where no DER object will be longer than limit.
            
             @param input stream containing ASN.1 encoded data.
             @param limit maximum size of a DER encoded object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1InputStream.#ctor(System.Byte[])">
             Create an ASN1InputStream based on the input byte array. The length of DER objects in
             the stream is automatically limited to the length of the input array.
            
             @param input array containing ASN.1 encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1InputStream.BuildObject(System.Int32,System.Int32,System.Int32)">
            build an object given its tag and the number of bytes to construct it from.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Asn1Null">
            A Null object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Object.FromByteArray(System.Byte[])">
            <summary>Create a base ASN.1 object from a byte array.</summary>
            <param name="data">The byte array to parse.</param>
            <returns>The base ASN.1 object represented by the byte array.</returns>
            <exception cref="T:System.IO.IOException">If there is a problem parsing the data.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Object.FromStream(System.IO.Stream)">
            <summary>Read a base ASN.1 object from a stream.</summary>
            <param name="inStr">The stream to parse.</param>
            <returns>The base ASN.1 object represented by the byte array.</returns>
            <exception cref="T:System.IO.IOException">If there is a problem parsing the data.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1OctetString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Octet string from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                          be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1OctetString.GetInstance(System.Object)">
             return an Octet string from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1OctetString.#ctor(System.Byte[])">
            @param string the octets making up the octet string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Sequence.GetInstance(System.Object)">
             return an Asn1Sequence from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Sequence.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return an ASN1 sequence from a tagged object. There is a special
             case here, if an object appears to have been explicitly tagged on
             reading but we were expecting it to be implicitly tagged in the
             normal course of events it indicates that we lost the surrounding
             sequence - so we need to add it back (this will happen if the tagged
             object is a sequence that contains other sequences). If you are
             dealing with implicitly tagged sequences you really <b>should</b>
             be using this method.
            
             @param obj the tagged object.
             @param explicitly true if the object is meant to be explicitly tagged,
                      false otherwise.
             @exception ArgumentException if the tagged object cannot
                      be converted.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Asn1Sequence.Item(System.Int32)">
             return the object at the sequence position indicated by index.
            
             @param index the sequence number (starting at zero) of the object
             @return the object at the sequence position indicated by index.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Set.GetInstance(System.Object)">
             return an ASN1Set from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Set.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return an ASN1 set from a tagged object. There is a special
             case here, if an object appears to have been explicitly tagged on
             reading but we were expecting it to be implicitly tagged in the
             normal course of events it indicates that we lost the surrounding
             set - so we need to add it back (this will happen if the tagged
             object is a sequence that contains other sequences). If you are
             dealing with implicitly tagged sets you really <b>should</b>
             be using this method.
            
             @param obj the tagged object.
             @param explicitly true if the object is meant to be explicitly tagged
                      false otherwise.
             @exception ArgumentException if the tagged object cannot
                      be converted.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Asn1Set.Item(System.Int32)">
             return the object at the set position indicated by index.
            
             @param index the set number (starting at zero) of the object
             @return the object at the set position indicated by index.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Asn1TaggedObject">
            ASN.1 TaggedObject - in ASN.1 notation this is any object preceded by
            a [n] where n is some number - these are assumed to follow the construction
            rules (as with sequences).
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.#ctor(System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.#ctor(System.Boolean,System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param explicitly true if the object is explicitly tagged.
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.IsExplicit">
            return whether or not the object may be explicitly tagged.
            <p>
            Note: if the object has been read from an input stream, the only
            time you can be sure if isExplicit is returning the true state of
            affairs is if it returns false. An implicitly tagged object may appear
            to be explicitly tagged, so you need to understand the context under
            which the reading was done as well, see GetObject below.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.GetObject">
            return whatever was following the tag.
            <p>
            Note: tagged objects are generally context dependent if you're
            trying to extract a tagged object you should be going via the
            appropriate GetInstance method.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.GetObjectParser(System.Int32,System.Boolean)">
            Return the object held in this tagged object as a parser assuming it has
            the type of the passed in tag. If the object doesn't have a parser
            associated with it, the base object is returned.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerApplicationSpecific">
            Base class for an application specific object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerApplicationSpecific.GetObject">
             Return the enclosed object assuming explicit tagging.
            
             @return  the resulting object
             @throws IOException if reconstruction fails.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerApplicationSpecific.GetObject(System.Int32)">
             Return the enclosed object assuming implicit tagging.
            
             @param derTagNo the type tag that should be applied to the object's contents.
             @return  the resulting object
             @throws IOException if reconstruction fails.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.GetInstance(System.Object)">
             return a Bit string from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Bit string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.#ctor(System.Byte[],System.Int32)">
            @param data the octets making up the bit string.
            @param padBits the number of extra bits at the end of the string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.GetOctets">
             Return the octets contained in this BIT STRING, checking that this BIT STRING really
             does represent an octet aligned string. Only use this method when the standard you are
             following dictates that the BIT STRING will be octet aligned.
            
             @return a copy of the octet aligned data.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerBitString.IntValue">
            @return the value of the bit string as an int (truncating if necessary)
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerBmpString">
            Der BMPString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.GetInstance(System.Object)">
             return a BMP string from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a BMP string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                          be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.#ctor(System.String)">
            basic constructor
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBoolean.GetInstance(System.Object)">
             return a bool from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBoolean.GetInstance(System.Boolean)">
            return a DerBoolean from the passed in bool.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBoolean.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Boolean from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerEnumerated.GetInstance(System.Object)">
             return an integer from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerEnumerated.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Enumerated from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerExternal">
            Class representing the DER-type External
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerExternal.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.DerInteger,Org.BouncyCastle.Asn1.Asn1Object,Org.BouncyCastle.Asn1.DerTaggedObject)">
            Creates a new instance of DerExternal
            See X.690 for more informations about the meaning of these parameters
            @param directReference The direct reference or <code>null</code> if not set.
            @param indirectReference The indirect reference or <code>null</code> if not set.
            @param dataValueDescriptor The data value descriptor or <code>null</code> if not set.
            @param externalData The external data in its encoded form.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerExternal.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.DerInteger,Org.BouncyCastle.Asn1.Asn1Object,System.Int32,Org.BouncyCastle.Asn1.Asn1Object)">
            Creates a new instance of DerExternal.
            See X.690 for more informations about the meaning of these parameters
            @param directReference The direct reference or <code>null</code> if not set.
            @param indirectReference The indirect reference or <code>null</code> if not set.
            @param dataValueDescriptor The data value descriptor or <code>null</code> if not set.
            @param encoding The encoding to be used for the external data
            @param externalData The external data
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerExternal.Encoding">
            The encoding of the content. Valid values are
            <ul>
            <li><code>0</code> single-ASN1-type</li>
            <li><code>1</code> OCTET STRING</li>
            <li><code>2</code> BIT STRING</li>
            </ul>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerGeneralizedTime">
            Generalized time object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.GetInstance(System.Object)">
             return a generalized time from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Generalized Time object from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.#ctor(System.String)">
             The correct format for this is YYYYMMDDHHMMSS[.f]Z, or without the Z
             for local time, or Z+-HHMM on the end, for difference between local
             time and UTC time. The fractional second amount f must consist of at
             least one number with trailing zeroes removed.
            
             @param time the time string.
             @exception ArgumentException if string is an illegal format.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.#ctor(System.DateTime)">
            base constructor from a local time object
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerGeneralizedTime.TimeString">
            Return the time.
            @return The time string as it appeared in the encoded object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.GetTime">
            return the time - always in the form of
             YYYYMMDDhhmmssGMT(+hh:mm|-hh:mm).
            <p>
            Normally in a certificate we would expect "Z" rather than "GMT",
            however adding the "GMT" means we can just use:
            <pre>
                dateF = new SimpleDateFormat("yyyyMMddHHmmssz");
            </pre>
            To read in the time and Get a date which is compatible with our local
            time zone.</p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerIA5String">
            Der IA5String object - this is an ascii string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.GetInstance(System.Object)">
             return a IA5 string from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an IA5 string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.#ctor(System.Byte[])">
            basic constructor - with bytes.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.#ctor(System.String)">
            basic constructor - without validation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.#ctor(System.String,System.Boolean)">
             Constructor with optional validation.
            
             @param string the base string to wrap.
             @param validate whether or not to check the string.
             @throws ArgumentException if validate is true and the string
             contains characters that should not be in an IA5String.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.IsIA5String(System.String)">
             return true if the passed in String can be represented without
             loss as an IA5String, false otherwise.
            
             @return true if in printable set, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerInteger.GetInstance(System.Object)">
             return an integer from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerInteger.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Integer from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param isExplicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerInteger.PositiveValue">
            in some cases positive values Get crammed into a space,
            that's not quite big enough...
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerNull">
            A Null object.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerNumericString">
            Der NumericString object - this is an ascii string of characters {0,1,2,3,4,5,6,7,8,9, }.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.GetInstance(System.Object)">
             return a Numeric string from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Numeric string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.#ctor(System.Byte[])">
            basic constructor - with bytes.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.#ctor(System.String)">
            basic constructor -  without validation..
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.#ctor(System.String,System.Boolean)">
             Constructor with optional validation.
            
             @param string the base string to wrap.
             @param validate whether or not to check the string.
             @throws ArgumentException if validate is true and the string
             contains characters that should not be in a NumericString.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.IsNumericString(System.String)">
             Return true if the string can be represented as a NumericString ('0'..'9', ' ')
            
             @param str string to validate.
             @return true if numeric, fale otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerObjectIdentifier.GetInstance(System.Object)">
             return an Oid from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerObjectIdentifier.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an object Identifier from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerObjectIdentifier.On(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            Return  true if this oid is an extension of the passed in branch, stem.
            @param stem the arc or branch that is a possible parent.
            @return  true if the branch is on the passed in stem, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerOctetString.#ctor(System.Byte[])">
            <param name="str">The octets making up the octet string.</param>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerPrintableString">
            Der PrintableString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.GetInstance(System.Object)">
             return a printable string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Printable string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.#ctor(System.String)">
            basic constructor - this does not validate the string
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.#ctor(System.String,System.Boolean)">
             Constructor with optional validation.
            
             @param string the base string to wrap.
             @param validate whether or not to check the string.
             @throws ArgumentException if validate is true and the string
             contains characters that should not be in a PrintableString.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.IsPrintableString(System.String)">
             return true if the passed in String can be represented without
             loss as a PrintableString, false otherwise.
            
             @return true if in printable set, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSequence.#ctor">
            create an empty sequence
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing one object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a sequence containing a vector of objects.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerSet">
            A Der encoded set object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSet.#ctor">
            create an empty set
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSet.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param obj - a single object that makes up the set.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSet.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            @param v - a vector of objects making up the set.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerT61String">
            Der T61String (also the teletex string) - 8-bit characters
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.GetInstance(System.Object)">
             return a T61 string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an T61 string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.#ctor(System.Byte[])">
            basic constructor - with bytes.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.#ctor(System.String)">
            basic constructor - with string.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerTaggedObject">
            DER TaggedObject - in ASN.1 notation this is any object preceded by
            a [n] where n is some number - these are assumed to follow the construction
            rules (as with sequences).
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerTaggedObject.#ctor(System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerTaggedObject.#ctor(System.Boolean,System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param explicitly true if an explicitly tagged object.
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerTaggedObject.#ctor(System.Int32)">
            create an implicitly tagged object that contains a zero
            length sequence.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerUniversalString">
            Der UniversalString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUniversalString.GetInstance(System.Object)">
             return a Universal string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUniversalString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Universal string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUniversalString.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerUnknownTag">
            We insert one of these when we find a tag we don't recognise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUnknownTag.#ctor(System.Int32,System.Byte[])">
            @param tag the tag value.
            @param data the contents octets.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerUtcTime">
            UTC time object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.GetInstance(System.Object)">
             return an UTC Time from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an UTC Time from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.#ctor(System.String)">
            The correct format for this is YYMMDDHHMMSSZ (it used to be that seconds were
            never encoded. When you're creating one of these objects from scratch, that's
            what you want to use, otherwise we'll try to deal with whatever Gets read from
            the input stream... (this is why the input format is different from the GetTime()
            method output).
            <p>
            @param time the time string.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.#ctor(System.DateTime)">
            base constructor from a DateTime object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.ToDateTime">
             return the time as a date based on whatever a 2 digit year will return. For
             standardised processing use ToAdjustedDateTime().
            
             @return the resulting date
             @exception ParseException if the date string cannot be parsed.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.ToAdjustedDateTime">
             return the time as an adjusted date
             in the range of 1950 - 2049.
            
             @return a date in the range of 1950 to 2049.
             @exception ParseException if the date string cannot be parsed.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerUtcTime.TimeString">
            return the time - always in the form of
             YYMMDDhhmmssGMT(+hh:mm|-hh:mm).
            <p>
            Normally in a certificate we would expect "Z" rather than "GMT",
            however adding the "GMT" means we can just use:
            <pre>
                dateF = new SimpleDateFormat("yyMMddHHmmssz");
            </pre>
            To read in the time and Get a date which is compatible with our local
            time zone.</p>
            <p>
            <b>Note:</b> In some cases, due to the local date processing, this
            may lead to unexpected results. If you want to stick the normal
            convention of 1950 to 2049 use the GetAdjustedTime() method.</p>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerUtcTime.AdjustedTimeString">
            <summary>
            Return a time string as an adjusted date with a 4 digit year.
            This goes in the range of 1950 - 2049.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerUtf8String">
            Der UTF8String object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.GetInstance(System.Object)">
             return an UTF8 string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an UTF8 string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.#ctor(System.String)">
            basic constructor
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerVisibleString">
            Der VisibleString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.GetInstance(System.Object)">
             return a Visible string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Visible string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.#ctor(System.String)">
            basic constructor
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IAsn1Choice">
            Marker interface for CHOICE objects - if you implement this in a roll-your-own
            object, any attempt to tag the object implicitly will convert the tag to an
            explicit one as the encoding rules require.
            <p>
            If you use this interface your class should also implement the getInstance
            pattern which takes a tag object and the tagging mode used. 
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IAsn1String">
            basic interface for Der string objects.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.OidTokenizer">
            class for breaking up an Oid into it's component tokens, ala
            java.util.StringTokenizer. We need this class as some of the
            lightweight Java environment don't support classes like
            StringTokenizer.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.CertificationRequest">
            Pkcs10 Certfication request object.
            <pre>
            CertificationRequest ::= Sequence {
              certificationRequestInfo  CertificationRequestInfo,
              signatureAlgorithm        AlgorithmIdentifier{{ SignatureAlgorithms }},
              signature                 BIT STRING
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.CertificationRequestInfo">
             Pkcs10 CertificationRequestInfo object.
             <pre>
              CertificationRequestInfo ::= Sequence {
               version             Integer { v1(0) } (v1,...),
               subject             Name,
               subjectPKInfo   SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
               attributes          [0] Attributes{{ CRIAttributes }}
              }
            
              Attributes { ATTRIBUTE:IOSet } ::= Set OF Attr{{ IOSet }}
            
              Attr { ATTRIBUTE:IOSet } ::= Sequence {
                type    ATTRIBUTE.&amp;id({IOSet}),
                values  Set SIZE(1..MAX) OF ATTRIBUTE.&amp;Type({IOSet}{\@type})
              }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.EncryptedPrivateKeyInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             EncryptedPrivateKeyInfo ::= Sequence {
                  encryptionAlgorithm AlgorithmIdentifier {{KeyEncryptionAlgorithms}},
                  encryptedData EncryptedData
             }
            
             EncryptedData ::= OCTET STRING
            
             KeyEncryptionAlgorithms ALGORITHM-IDENTIFIER ::= {
                      ... -- For local profiles
             }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo.ToAsn1Object">
             write out an RSA private key with its associated information
             as described in Pkcs8.
             <pre>
                  PrivateKeyInfo ::= Sequence {
                                          version Version,
                                          privateKeyAlgorithm AlgorithmIdentifier {{PrivateKeyAlgorithms}},
                                          privateKey PrivateKey,
                                          attributes [0] IMPLICIT Attributes OPTIONAL
                                      }
                  Version ::= Integer {v1(0)} (v1,...)
            
                  PrivateKey ::= OCTET STRING
            
                  Attributes ::= Set OF Attr
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsaPrivateKeyStructure.ToAsn1Object">
             This outputs the key in Pkcs1v2 format.
             <pre>
                  RsaPrivateKey ::= Sequence {
                                      version Version,
                                      modulus Integer, -- n
                                      publicExponent Integer, -- e
                                      privateExponent Integer, -- d
                                      prime1 Integer, -- p
                                      prime2 Integer, -- q
                                      exponent1 Integer, -- d mod (p-1)
                                      exponent2 Integer, -- d mod (q-1)
                                      coefficient Integer -- (inverse of q) mod p
                                  }
            
                  Version ::= Integer
             </pre>
             <p>This routine is written to output Pkcs1 version 0, private keys.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsassaPssParameters.#ctor">
            The default version
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsassaPssParameters.ToAsn1Object">
             <pre>
             RSASSA-PSS-params ::= SEQUENCE {
               hashAlgorithm      [0] OAEP-PSSDigestAlgorithms  DEFAULT sha1,
                maskGenAlgorithm   [1] PKCS1MGFAlgorithms  DEFAULT mgf1SHA1,
                saltLength         [2] INTEGER  DEFAULT 20,
                trailerField       [3] TrailerField  DEFAULT trailerFieldBC
              }
            
             OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
                { OID id-sha1 PARAMETERS NULL   }|
                { OID id-sha256 PARAMETERS NULL }|
                { OID id-sha384 PARAMETERS NULL }|
                { OID id-sha512 PARAMETERS NULL },
                ...  -- Allows for future expansion --
             }
            
             PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
               { OID id-mgf1 PARAMETERS OAEP-PSSDigestAlgorithms },
                ...  -- Allows for future expansion --
             }
            
             TrailerField ::= INTEGER { trailerFieldBC(1) }
             </pre>
             @return the asn1 primitive representing the parameters.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier.Algorithm">
            <summary>
            Return the OID in the Algorithm entry of this identifier.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier.Parameters">
            <summary>
            Return the parameters structure in the Parameters entry of this identifier.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
                 AlgorithmIdentifier ::= Sequence {
                                       algorithm OBJECT IDENTIFIER,
                                       parameters ANY DEFINED BY algorithm OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeX509.GetInstance(System.Object)">
             return an Attr object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeX509.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Attr ::= Sequence {
                attrType OBJECT IDENTIFIER,
                attrValues Set OF AttributeValue
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier">
             The AuthorityKeyIdentifier object.
             <pre>
             id-ce-authorityKeyIdentifier OBJECT IDENTIFIER ::=  { id-ce 35 }
            
               AuthorityKeyIdentifier ::= Sequence {
                  keyIdentifier             [0] IMPLICIT KeyIdentifier           OPTIONAL,
                  authorityCertIssuer       [1] IMPLICIT GeneralNames            OPTIONAL,
                  authorityCertSerialNumber [2] IMPLICIT CertificateSerialNumber OPTIONAL  }
            
               KeyIdentifier ::= OCTET STRING
             </pre>
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
                     *
                     * Calulates the keyidentifier using a SHA1 hash over the BIT STRING
                     * from SubjectPublicKeyInfo as defined in RFC2459.
                     *
                     * Example of making a AuthorityKeyIdentifier:
                     * <pre>
            	     *   SubjectPublicKeyInfo apki = new SubjectPublicKeyInfo((ASN1Sequence)new ASN1InputStream(
            		 *       publicKey.getEncoded()).readObject());
                     *   AuthorityKeyIdentifier aki = new AuthorityKeyIdentifier(apki);
                     * </pre>
                     *
                     *
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo,Org.BouncyCastle.Asn1.X509.GeneralNames,Org.BouncyCastle.Math.BigInteger)">
            create an AuthorityKeyIdentifier with the GeneralNames tag and
            the serial number provided as well.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(Org.BouncyCastle.Asn1.X509.GeneralNames,Org.BouncyCastle.Math.BigInteger)">
            create an AuthorityKeyIdentifier with the GeneralNames tag and
            the serial number provided.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(System.Byte[])">
            create an AuthorityKeyIdentifier with a precomputed key identifier
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(System.Byte[],Org.BouncyCastle.Asn1.X509.GeneralNames,Org.BouncyCastle.Math.BigInteger)">
            create an AuthorityKeyIdentifier with a precomupted key identifier
            and the GeneralNames tag and the serial number provided as well.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.BasicConstraints.#ctor(System.Int32)">
             create a cA=true object for the given path length constraint.
            
             @param pathLenConstraint
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.BasicConstraints.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            BasicConstraints := Sequence {
               cA                  Boolean DEFAULT FALSE,
               pathLenConstraint   Integer (0..MAX) OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.DigestInfo">
            The DigestInfo object.
            <pre>
            DigestInfo::=Sequence{
                     digestAlgorithm  AlgorithmIdentifier,
                     digest OCTET STRING }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.ExtendedKeyUsage">
            The extendedKeyUsage object.
            <pre>
                 extendedKeyUsage ::= Sequence SIZE (1..MAX) OF KeyPurposeId
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.ExtendedKeyUsage.GetAllUsages">
            Returns all extended key usages.
            The returned ArrayList contains DerObjectIdentifier instances.
            @return An ArrayList with all key purposes.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.GeneralName">
             The GeneralName object.
             <pre>
             GeneralName ::= CHOICE {
                  otherName                       [0]     OtherName,
                  rfc822Name                      [1]     IA5String,
                  dNSName                         [2]     IA5String,
                  x400Address                     [3]     ORAddress,
                  directoryName                   [4]     Name,
                  ediPartyName                    [5]     EDIPartyName,
                  uniformResourceIdentifier       [6]     IA5String,
                  iPAddress                       [7]     OCTET STRING,
                  registeredID                    [8]     OBJECT IDENTIFIER}
            
             OtherName ::= Sequence {
                  type-id    OBJECT IDENTIFIER,
                  value      [0] EXPLICIT ANY DEFINED BY type-id }
            
             EDIPartyName ::= Sequence {
                  nameAssigner            [0]     DirectoryString OPTIONAL,
                  partyName               [1]     DirectoryString }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralName.#ctor(Org.BouncyCastle.Asn1.Asn1Object,System.Int32)">
             When the subjectAltName extension contains an Internet mail address,
             the address MUST be included as an rfc822Name. The format of an
             rfc822Name is an "addr-spec" as defined in RFC 822 [RFC 822].
            
             When the subjectAltName extension contains a domain name service
             label, the domain name MUST be stored in the dNSName (an IA5String).
             The name MUST be in the "preferred name syntax," as specified by RFC
             1034 [RFC 1034].
            
             When the subjectAltName extension contains a URI, the name MUST be
             stored in the uniformResourceIdentifier (an IA5String). The name MUST
             be a non-relative URL, and MUST follow the URL syntax and encoding
             rules specified in [RFC 1738].  The name must include both a scheme
             (e.g., "http" or "ftp") and a scheme-specific-part.  The scheme-
             specific-part must include a fully qualified domain name or IP
             address as the host.
            
             When the subjectAltName extension contains a iPAddress, the address
             MUST be stored in the octet string in "network byte order," as
             specified in RFC 791 [RFC 791]. The least significant bit (LSB) of
             each octet is the LSB of the corresponding byte in the network
             address. For IP Version 4, as specified in RFC 791, the octet string
             MUST contain exactly four octets.  For IP Version 6, as specified in
             RFC 1883, the octet string MUST contain exactly sixteen octets [RFC
             1883].
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralName.#ctor(System.Int32,System.String)">
             Create a GeneralName for the given tag from the passed in string.
             <p>
             This constructor can handle:
             <ul>
             <li>rfc822Name</li>
             <li>iPAddress</li>
             <li>directoryName</li>
             <li>dNSName</li>
             <li>uniformResourceIdentifier</li>
             <li>registeredID</li>
             </ul>
             For x400Address, otherName and ediPartyName there is no common string
             format defined.
             </p><p>
             Note: A directory name can be encoded in different ways into a byte
             representation. Be aware of this if the byte representation is used for
             comparing results.
             </p>
            
             @param tag tag number
             @param name string representation of name
             @throws ArgumentException if the string encoding is not correct or
                         not supported.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralNames.#ctor(Org.BouncyCastle.Asn1.X509.GeneralName)">
            <summary>Construct a GeneralNames object containing one GeneralName.</summary>
            <param name="name">The name to be contained.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralNames.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            GeneralNames ::= Sequence SIZE {1..MAX} OF GeneralName
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.KeyPurposeID">
            The KeyPurposeID object.
            <pre>
                KeyPurposeID ::= OBJECT IDENTIFIER
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.KeyUsage">
             The KeyUsage object.
             <pre>
                id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
            
                KeyUsage ::= BIT STRING {
                     digitalSignature        (0),
                     nonRepudiation          (1),
                     keyEncipherment         (2),
                     dataEncipherment        (3),
                     keyAgreement            (4),
                     keyCertSign             (5),
                     cRLSign                 (6),
                     encipherOnly            (7),
                     decipherOnly            (8) }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.KeyUsage.#ctor(System.Int32)">
             Basic constructor.
            
             @param usage - the bitwise OR of the Key Usage flags giving the
             allowed uses for the key.
             e.g. (KeyUsage.keyEncipherment | KeyUsage.dataEncipherment)
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RsaPublicKeyStructure.ToAsn1Object">
            This outputs the key in Pkcs1v2 format.
            <pre>
                 RSAPublicKey ::= Sequence {
                                     modulus Integer, -- n
                                     publicExponent Integer, -- e
                                 }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo">
            The object that contains the public key stored in a certficate.
            <p>
            The GetEncoded() method in the public keys in the JCE produces a DER
            encoded one of these.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo.GetPublicKey">
             for when the public key is an encoded object - if the bitstring
             can't be decoded this routine raises an IOException.
            
             @exception IOException - if the bit string doesn't represent a Der
             encoded object.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo.PublicKeyData">
            for when the public key is raw bits...
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            SubjectPublicKeyInfo ::= Sequence {
                                     algorithm AlgorithmIdentifier,
                                     publicKey BIT STRING }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.TbsCertificateStructure">
            The TbsCertificate object.
            <pre>
            TbsCertificate ::= Sequence {
                 version          [ 0 ]  Version DEFAULT v1(0),
                 serialNumber            CertificateSerialNumber,
                 signature               AlgorithmIdentifier,
                 issuer                  Name,
                 validity                Validity,
                 subject                 Name,
                 subjectPublicKeyInfo    SubjectPublicKeyInfo,
                 issuerUniqueID    [ 1 ] IMPLICIT UniqueIdentifier OPTIONAL,
                 subjectUniqueID   [ 2 ] IMPLICIT UniqueIdentifier OPTIONAL,
                 extensions        [ 3 ] Extensions OPTIONAL
                 }
            </pre>
            <p>
            Note: issuerUniqueID and subjectUniqueID are both deprecated by the IETF. This class
            will parse them, but you really shouldn't be creating new ones.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Time.#ctor(System.DateTime)">
            creates a time object from a given date - if the date is between 1950
            and 2049 a UTCTime object is Generated, otherwise a GeneralizedTime
            is used.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Time.ToDateTime">
            <summary>
            Return our time as DateTime.
            </summary>
            <returns>A date time.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Time.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Time ::= CHOICE {
                        utcTime        UTCTime,
                        generalTime    GeneralizedTime }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509CertificateStructure">
            an X509Certificate structure.
            <pre>
             Certificate ::= Sequence {
                 tbsCertificate          TbsCertificate,
                 signatureAlgorithm      AlgorithmIdentifier,
                 signature               BIT STRING
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509DefaultEntryConverter">
            The default converter for X509 DN entries when going from their
            string value to ASN.1 strings.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509DefaultEntryConverter.GetConvertedValue(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String)">
             Apply default conversion for the given value depending on the oid
             and the character range of the value.
            
             @param oid the object identifier for the DN entry
             @param value the value associated with it
             @return the ASN.1 equivalent for the string value.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509Extension">
            an object for the elements in the X.509 V3 extension block.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extension.ConvertValueToObject(Org.BouncyCastle.Asn1.X509.X509Extension)">
            <sumary>Convert the value of the passed in extension to an object.</sumary>
            <param name="ext">The extension to parse.</param>
            <returns>The object the value string contains.</returns>
            <exception cref="T:System.ArgumentException">If conversion is not possible.</exception>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectDirectoryAttributes">
            Subject Directory Attributes
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectKeyIdentifier">
            Subject Key Identifier
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.KeyUsage">
            Key Usage
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.PrivateKeyUsagePeriod">
            Private Key Usage Period
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectAlternativeName">
            Subject Alternative Name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.IssuerAlternativeName">
            Issuer Alternative Name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.BasicConstraints">
            Basic Constraints
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CrlNumber">
            CRL Number
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.ReasonCode">
            Reason code
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.InstructionCode">
            Hold Instruction Code
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.InvalidityDate">
            Invalidity Date
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.DeltaCrlIndicator">
            Delta CRL indicator
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.IssuingDistributionPoint">
            Issuing Distribution Point
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CertificateIssuer">
            Certificate Issuer
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.NameConstraints">
            Name Constraints
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CrlDistributionPoints">
            CRL Distribution Points
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CertificatePolicies">
            Certificate Policies
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.PolicyMappings">
            Policy Mappings
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.AuthorityKeyIdentifier">
            Authority Key Identifier
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.PolicyConstraints">
            Policy Constraints
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.ExtendedKeyUsage">
            Extended Key Usage
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.FreshestCrl">
            Freshest CRL
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.InhibitAnyPolicy">
            Inhibit Any Policy
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.AuthorityInfoAccess">
            Authority Info Access
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectInfoAccess">
            Subject Info Access
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.LogoType">
            Logo Type
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.BiometricInfo">
            BiometricInfo
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.QCStatements">
            QCStatements
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.AuditIdentity">
            Audit identity extension in attribute certificates.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.NoRevAvail">
            NoRevAvail extension in attribute certificates.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.TargetInformation">
            TargetInformation extension in attribute certificates.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
            
             the extensions are a list of constructed sequences, either with (Oid, OctetString) or (Oid, Boolean, OctetString)
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.IDictionary)">
            constructor from a table of extensions.
            <p>
            it's is assumed the table contains Oid/string pairs.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.IList,System.Collections.IDictionary)">
            Constructor from a table of extensions with ordering.
            <p>
            It's is assumed the table contains Oid/string pairs.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.IList,System.Collections.IList)">
             Constructor from two vectors
            
             @param objectIDs an ArrayList of the object identifiers.
             @param values an ArrayList of the extension values.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.X509Extensions.ExtensionOids">
            return an Enumeration of the extension field's object ids.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.GetExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the extension represented by the object identifier
             passed in.
            
             @return the extension if it's present, null otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.ToAsn1Object">
             <pre>
                 Extensions        ::=   SEQUENCE SIZE (1..MAX) OF Extension
            
                 Extension         ::=   SEQUENCE {
                    extnId            EXTENSION.&amp;id ({ExtensionSet}),
                    critical          BOOLEAN DEFAULT FALSE,
                    extnValue         OCTET STRING }
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator">
            <remarks>Generator for X.509 extensions</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.Reset">
            <summary>Reset the generator</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,Org.BouncyCastle.Asn1.Asn1Encodable)">
            <summary>
            Add an extension with the given oid and the passed in value to be included
            in the OCTET STRING associated with the extension.
            </summary>
            <param name="oid">OID for the extension.</param>
            <param name="critical">True if critical, false otherwise.</param>
            <param name="extValue">The ASN.1 object to be included in the extension.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,System.Byte[])">
            <summary>
            Add an extension with the given oid and the passed in byte array to be wrapped
            in the OCTET STRING associated with the extension.
            </summary>
            <param name="oid">OID for the extension.</param>
            <param name="critical">True if critical, false otherwise.</param>
            <param name="extValue">The byte array to be wrapped.</param>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.IsEmpty">
            <summary>Return true if there are no extension present in this generator.</summary>
            <returns>True if empty, false otherwise</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.Generate">
            <summary>Generate an X509Extensions object based on the current state of the generator.</summary>
            <returns>An <c>X509Extensions</c> object</returns>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509Name">
             <pre>
                 RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
            
                 RelativeDistinguishedName ::= SET SIZE (1..MAX) OF AttributeTypeAndValue
            
                 AttributeTypeAndValue ::= SEQUENCE {
                                               type  OBJECT IDENTIFIER,
                                               value ANY }
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.C">
            country code - StringType(SIZE(2))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.O">
            organization - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.OU">
            organizational unit name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.T">
            Title
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.CN">
            common name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Street">
            street - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.SerialNumber">
            device serial number name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.L">
            locality name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.ST">
            state, or province name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Surname">
            Naming attributes of type X520name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.BusinessCategory">
            businessCategory - DirectoryString(SIZE(1..128)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.PostalCode">
            postalCode - DirectoryString(SIZE(1..40)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DnQualifier">
            dnQualifier - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Pseudonym">
            RFC 3039 Pseudonym - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DateOfBirth">
            RFC 3039 DateOfBirth - GeneralizedTime - YYYYMMDD000000Z
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.PlaceOfBirth">
            RFC 3039 PlaceOfBirth - DirectoryString(SIZE(1..128)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Gender">
            RFC 3039 DateOfBirth - PrintableString (SIZE(1)) -- "M", "F", "m" or "f"
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.CountryOfCitizenship">
            RFC 3039 CountryOfCitizenship - PrintableString (SIZE (2)) -- ISO 3166
            codes only
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.CountryOfResidence">
            RFC 3039 CountryOfCitizenship - PrintableString (SIZE (2)) -- ISO 3166
            codes only
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.NameAtBirth">
            ISIS-MTT NameAtBirth - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.PostalAddress">
            RFC 3039 PostalAddress - SEQUENCE SIZE (1..6) OF
            DirectoryString(SIZE(1..30))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DmdName">
            RFC 2256 dmdName
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.TelephoneNumber">
            id-at-telephoneNumber
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Name">
            id-at-name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.EmailAddress">
            Email address (RSA PKCS#9 extension) - IA5String.
            <p>Note: if you're trying to be ultra orthodox, don't use this! It shouldn't be in here.</p>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.UnstructuredName">
            more from PKCS#9
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.E">
            email address in Verisign certificates
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.UID">
            LDAP User id.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.X509Name.DefaultReverse">
            determines whether or not strings should be processed and printed
            from back to front.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DefaultSymbols">
            default look up table translating OID values into their common symbols following
            the convention in RFC 2253 with a few extras
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.RFC2253Symbols">
            look up table translating OID values into their common symbols following the convention in RFC 2253
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.RFC1779Symbols">
             look up table translating OID values into their common symbols following the convention in RFC 1779
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DefaultLookup">
            look up table translating common symbols into their OIDS.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return a X509Name based on the passed in tagged object.
            
             @param obj tag object holding name.
             @param explicitly true if explicitly tagged false otherwise.
             @return the X509Name
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence
            
             the principal will be a list of constructed sets, each containing an (OID, string) pair.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.IList,System.Collections.IDictionary)">
            Constructor from a table of attributes with ordering.
            <p>
            it's is assumed the table contains OID/string pairs, and the contents
            of the table are copied into an internal table as part of the
            construction process. The ordering ArrayList should contain the OIDs
            in the order they are meant to be encoded or printed in ToString.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.IList,System.Collections.IDictionary,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Constructor from a table of attributes with ordering.
            <p>
            it's is assumed the table contains OID/string pairs, and the contents
            of the table are copied into an internal table as part of the
            construction process. The ordering ArrayList should contain the OIDs
            in the order they are meant to be encoded or printed in ToString.</p>
            <p>
            The passed in converter will be used to convert the strings into their
            ASN.1 counterparts.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.IList,System.Collections.IList)">
            Takes two vectors one of the oids and the other of the values.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.IList,System.Collections.IList,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes two vectors one of the oids and the other of the values.
            <p>
            The passed in converter will be used to convert the strings into their
            ASN.1 counterparts.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.String)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.String,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes with each
            string value being converted to its associated ASN.1 type using the passed
            in converter.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.String)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes. If reverse
            is true, create the encoded version of the sequence starting from the
            last element in the string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.String,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes with each
            string value being converted to its associated ASN.1 type using the passed
            in converter. If reverse is true the ASN.1 sequence representing the DN will
            be built by starting at the end of the string, rather than the start.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.Collections.IDictionary,System.String)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes. lookUp
            should provide a table of lookups, indexed by lowercase only strings and
            yielding a DerObjectIdentifier, other than that OID. and numeric oids
            will be processed automatically.
            <br/>
            If reverse is true, create the encoded version of the sequence
            starting from the last element in the string.
            @param reverse true if we should start scanning from the end (RFC 2553).
            @param lookUp table of names and their oids.
            @param dirName the X.500 string to be parsed.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.Collections.IDictionary,System.String,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes. lookUp
            should provide a table of lookups, indexed by lowercase only strings and
            yielding a DerObjectIdentifier, other than that OID. and numeric oids
            will be processed automatically. The passed in converter is used to convert the
            string values to the right of each equals sign to their ASN.1 counterparts.
            <br/>
            @param reverse true if we should start scanning from the end, false otherwise.
            @param lookUp table of names and oids.
            @param dirName the string dirName
            @param converter the converter to convert string values into their ASN.1 equivalents
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetOidList">
            return an IList of the oids in the name, in the order they were found.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetValueList">
            return an IList of the values found in the name, in the order they
            were found.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetValueList(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return an IList of the values found in the name, in the order they
            were found, with the DN label corresponding to passed in oid.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.Equivalent(Org.BouncyCastle.Asn1.X509.X509Name,System.Boolean)">
            <param name="other">The X509Name object to test equivalency against.</param>
            <param name="inOrder">If true, the order of elements must be the same,
            as well as the values associated with each element.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.Equivalent(Org.BouncyCastle.Asn1.X509.X509Name)">
            test for equivalence - note: case is ignored.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.ToString(System.Boolean,System.Collections.IDictionary)">
             convert the structure to a string - if reverse is true the
             oids and values are listed out starting with the last element
             in the sequence (ala RFC 2253), otherwise the string will begin
             with the first element of the structure. If no string definition
             for the oid is found in oidSymbols the string value of the oid is
             added. Two standard symbol tables are provided DefaultSymbols, and
             RFC2253Symbols as part of this class.
            
             @param reverse if true start at the end of the sequence and work back.
             @param oidSymbols look up table strings for oids.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509NameEntryConverter">
                 * It turns out that the number of standard ways the fields in a DN should be
                 * encoded into their ASN.1 counterparts is rapidly approaching the
                 * number of machines on the internet. By default the X509Name class
                 * will produce UTF8Strings in line with the current recommendations (RFC 3280).
                 * <p>
                 * An example of an encoder look like below:
                 * <pre>
                 * internal class X509DirEntryConverter
                 *     : X509NameEntryConverter
                 * {
                 *     public Asn1Object GetConvertedValue(
                 *         DerObjectIdentifier  oid,
                 *         string               value)
                 *     {
                 *         if (str.Length() != 0 &amp;&amp; str.charAt(0) == '#')
                 *         {
                 *             return ConvertHexEncoded(str, 1);
                 *         }
                 *         if (oid.Equals(EmailAddress))
                 *         {
                 *             return new DerIA5String(str);
                 *         }
                 *         else if (CanBePrintable(str))
                 *         {
                 *             return new DerPrintableString(str);
                 *         }
                 *         else if (CanBeUTF8(str))
                 *         {
                 *             return new DerUtf8String(str);
                 *         }
                 *         else
                 *         {
                 *             return new DerBmpString(str);
                 *         }
                 *     }
                 * }
            	 * </pre>
            	 * </p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509NameEntryConverter.ConvertHexEncoded(System.String,System.Int32)">
             Convert an inline encoded hex string rendition of an ASN.1
             object back into its corresponding ASN.1 object.
            
             @param str the hex encoded object
             @param off the index at which the encoding starts
             @return the decoded object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509NameEntryConverter.CanBePrintable(System.String)">
            return true if the passed in string can be represented without
            loss as a PrintableString, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509NameEntryConverter.GetConvertedValue(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String)">
             Convert the passed in string value into the appropriate ASN.1
             encoded object.
            
             @param oid the oid associated with the value in the DN.
             @param value the value of the particular DN component.
             @return the ASN.1 equivalent for the value.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509NameTokenizer">
            class for breaking up an X500 Name into it's component tokens, ala
            java.util.StringTokenizer. We need this class as some of the
            lightweight Java environment don't support classes like
            StringTokenizer.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair">
            a holding class for public/private parameter pairs.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair.#ctor(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
             basic constructor.
            
             @param publicParam a public key parameters object.
             @param privateParam the corresponding private key parameters.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair.Public">
             return the public key parameters.
            
             @return the public key parameters.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair.Private">
             return the private key parameters.
            
             @return the private key parameters.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.BufferedBlockCipher">
            A wrapper class that allows block ciphers to be used to process data in
            a piecemeal fashion. The BufferedBlockCipher outputs a block only when the
            buffer is full and more data is being added, or on a doFinal.
            <p>
            Note: in the case where the underlying cipher is either a CFB cipher or an
            OFB one the last block may not be a multiple of the block size.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.#ctor">
            constructor for subclasses
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Create a buffered block cipher without padding.
            
             @param cipher the underlying block cipher this buffering object wraps.
             false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.GetBlockSize">
             return the blocksize for the underlying cipher.
            
             @return the blocksize for the underlying cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output, or the input is not block size aligned and should be.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
             @exception DataLengthException if the input is not block size
             aligned.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.Reset">
            Reset the buffer and cipher. After resetting the object is in the same
            state as it was after the last init (if there was one).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.DataLengthException">
            this exception is thrown if a buffer that is meant to have output
            copied into it turns out to be too short, or if we've been given
            insufficient input. In general this exception will Get thrown rather
            than an ArrayOutOfBounds exception.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.DataLengthException.#ctor">
            base constructor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.DataLengthException.#ctor(System.String)">
             create a DataLengthException with the given message.
            
             @param message the message to be carried with the exception.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.GeneralDigest">
            base implementation of MD4 family style digest as outlined in
            "Handbook of Applied Cryptography", pages 344 - 347.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.LongDigest">
            Base class for SHA-384 and SHA-512.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.LongDigest.#ctor">
            Constructor for variable length word
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.LongDigest.#ctor(Org.BouncyCastle.Crypto.Digests.LongDigest)">
            Copy constructor.  We are using copy constructors in place
            of the object.Clone() interface as this interface is not
            supported by J2ME.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.LongDigest.AdjustByteCounts">
            adjust the byte counts so that byteCount2 represents the
            upper long (less 3 bits) word of the byte count.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha1Digest">
             implementation of SHA-1 as outlined in "Handbook of Applied Cryptography", pages 346 - 349.
            
             It is interesting to ponder why the, apart from the extra IV, the other difference here from MD5
             is the "endianness" of the word processing!
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha1Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha1Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha1Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha256Digest">
             Draft FIPS 180-2 implementation of SHA-256. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha256Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha256Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha256Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha384Digest">
             Draft FIPS 180-2 implementation of SHA-384. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha384Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha384Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha384Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha512Digest">
             Draft FIPS 180-2 implementation of SHA-512. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha512Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding">
            this does your basic Pkcs 1 v1.5 padding - whether or not you should be using this
            depends on your application - see Pkcs1 Version 2 for details.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.StrictLengthEnabledProperty">
            some providers fail to include the leading zero in PKCS1 encoded blocks. If you need to
            work with one of these set the system property Org.BouncyCastle.Pkcs1.Strict to false.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.StrictLengthEnabled">
            The same effect can be achieved by setting the static property directly
            <p>
            The static property is checked during construction of the encoding object, it is set to
            true by default.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher)">
            Basic constructor.
            @param cipher
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,System.Int32)">
            Constructor for decryption with a fixed plaintext length.
            
            @param cipher The cipher to use for cryptographic operation.
            @param pLen Length of the expected plaintext.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,System.Byte[])">
            Constructor for decryption with a fixed plaintext length and a fallback
            value that is returned, if the padding is incorrect.
            
            @param cipher
                       The cipher to use for cryptographic operation.
            @param fallback
                       The fallback value, we don't to a arraycopy here.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.CheckPkcs1Encoding(System.Byte[],System.Int32)">
            Checks if the argument is a correctly PKCS#1.5 encoded Plaintext
            for encryption.
            
            @param encoded The Plaintext.
            @param pLen Expected length of the plaintext.
            @return Either 0, if the encoding is correct, or -1, if it is incorrect.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.DecodeBlockOrRandom(System.Byte[],System.Int32,System.Int32)">
            Decode PKCS#1.5 encoding, and return a random value if the padding is not correct.
            
            @param in The encrypted block.
            @param inOff Offset in the encrypted block.
            @param inLen Length of the encrypted block.
            @param pLen Length of the desired output.
            @return The plaintext without padding, or a random value if the padding was incorrect.
            
            @throws InvalidCipherTextException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.DecodeBlock(System.Byte[],System.Int32,System.Int32)">
            @exception InvalidCipherTextException if the decrypted block is not in Pkcs1 format.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.AesFastEngine">
             an implementation of the AES (Rijndael)), from FIPS-197.
             <p>
             For further details see: <a href="http://csrc.nist.gov/encryption/aes/">http://csrc.nist.gov/encryption/aes/</a>.
            
             This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at
             <a href="http://fp.gladman.plus.com/cryptography_technology/rijndael/">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>
            
             There are three levels of tradeoff of speed vs memory
             Because java has no preprocessor), they are written as three separate classes from which to choose
            
             The fastest uses 8Kbytes of static tables to precompute round calculations), 4 256 word tables for encryption
             and 4 for decryption.
            
             The middle performance version uses only one 256 word table for each), for a total of 2Kbytes),
             adding 12 rotate operations per round to compute the values contained in the other tables from
             the contents of the first
            
             The slowest version uses no static tables at all and computes the values in each round
             </p>
             <p>
             This file contains the fast version with 8Kbytes of static tables for round precomputation
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesFastEngine.GenerateWorkingKey(System.Byte[],System.Boolean)">
            Calculate the necessary round keys
            The number of calculations depends on key size and block size
            AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits
            This code is written assuming those are the only possible values
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesFastEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesFastEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an AES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RijndaelEngine">
            an implementation of Rijndael, based on the documentation and reference implementation
            by Paulo Barreto, Vincent Rijmen, for v2.0 August '99.
            <p>
            Note: this implementation is based on information prior to readonly NIST publication.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.Mul0x2(System.Int32)">
            multiply two elements of GF(2^m)
            needed for MixColumn and InvMixColumn
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.KeyAddition(System.Int64[])">
            xor corresponding text input and round key input bytes
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.ShiftRow(System.Byte[])">
            Row 0 remains unchanged
            The other three rows are shifted a variable amount
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.Substitution(System.Byte[])">
            Replace every byte of the input by the byte at that place
            in the nonlinear S-box
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.MixColumn">
            Mix the bytes of every column in a linear way
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.InvMixColumn">
            Mix the bytes of every column in a linear way
            This is the opposite operation of Mixcolumn
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.GenerateWorkingKey(System.Byte[])">
            Calculate the necessary round keys
            The number of calculations depends on keyBits and blockBits
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.#ctor(System.Int32)">
             basic constructor - set the cipher up for a given blocksize
            
             @param blocksize the blocksize in bits, must be 128, 192, or 256.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Rijndael cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine">
            this does your basic RSA algorithm with blinding
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the RSA engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary RSA key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For RSA this is always one byte less than the key size on
             encryption, and the same length as the key size on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For RSA this is always one byte less than the key size on
             decryption, and the same length as the key size on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single block using the basic RSA algorithm.
            
             @param inBuf the input array.
             @param inOff the offset into the input buffer where the data starts.
             @param inLen the length of the data to be processed.
             @return the result of the RSA process.
             @exception DataLengthException the input block is too large.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RsaCoreEngine">
            this does your basic RSA algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaCoreEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the RSA engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary RSA key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaCoreEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For RSA this is always one byte less than the key size on
             encryption, and the same length as the key size on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaCoreEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For RSA this is always one byte less than the key size on
             decryption, and the same length as the key size on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RsaEngine">
            this does your basic RSA algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the RSA engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary RSA key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For RSA this is always one byte less than the key size on
             encryption, and the same length as the key size on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For RSA this is always one byte less than the key size on
             decryption, and the same length as the key size on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single block using the basic RSA algorithm.
            
             @param inBuf the input array.
             @param inOff the offset into the input buffer where the data starts.
             @param inLen the length of the data to be processed.
             @return the result of the RSA process.
             @exception DataLengthException the input block is too large.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher">
            <remarks>Base interface for a public/private key block cipher.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.GetInputBlockSize">
            <returns>The maximum size, in bytes, an input block may be.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.GetOutputBlockSize">
            <returns>The maximum size, in bytes, an output block will be.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process a block.</summary>
            <param name="inBuf">The input buffer.</param>
            <param name="inOff">The offset into <paramref>inBuf</paramref> that the input block begins.</param>
            <param name="inLen">The length of the input block.</param>
            <exception cref="T:Org.BouncyCastle.Crypto.InvalidCipherTextException">Input decrypts improperly.</exception>
            <exception cref="T:Org.BouncyCastle.Crypto.DataLengthException">Input is too large for the cipher.</exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBlockCipher">
            <remarks>Base interface for a symmetric key block cipher.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipher.GetBlockSize">
            <returns>The block size for this cipher, in bytes.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IBlockCipher.IsPartialBlockOkay">
            <summary>Indicates whether this cipher can handle partial blocks.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>Process a block.</summary>
            <param name="inBuf">The input buffer.</param>
            <param name="inOff">The offset into <paramref>inBuf</paramref> that the input block begins.</param>
            <param name="outBuf">The output buffer.</param>
            <param name="outOff">The offset into <paramref>outBuf</paramref> to write the output block.</param>
            <exception cref="T:Org.BouncyCastle.Crypto.DataLengthException">If input block is wrong size, or outBuf too small.</exception>
            <returns>The number of bytes processed and produced.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipher.Reset">
            <summary>
            Reset the cipher to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBlockResult">
            <summary>
            Operators that reduce their input to a single block return an object
            of this type.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockResult.Collect">
            <summary>
            Return the final result of the operation.
            </summary>
            <returns>A block of bytes, representing the result of an operation.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockResult.Collect(System.Byte[],System.Int32)">
            <summary>
            Store the final result of the operation by copying it into the destination array.
            </summary>
            <returns>The number of bytes copied into destination.</returns>
            <param name="destination">The byte array to copy the result into.</param>
            <param name="offset">The offset into destination to start copying the result at.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBufferedCipher">
            <remarks>Block cipher engines are expected to conform to this interface.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IBufferedCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBufferedCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">If true the cipher is initialised for encryption,
            if false for decryption.</param>
            <param name="parameters">The key and other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBufferedCipher.Reset">
            <summary>
            Reset the cipher. After resetting the cipher is in the same state
            as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ICipherParameters">
            all parameter classes implement this.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDigest">
            interface that a message digest conforms to.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IDigest.AlgorithmName">
             return the algorithm name
            
             @return the algorithm name
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.GetDigestSize">
             return the size, in bytes, of the digest produced by this message digest.
            
             @return the size, in bytes, of the digest produced by this message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.GetByteLength">
             return the size, in bytes, of the internal buffer used by this digest.
            
             @return the size, in bytes, of the internal buffer used by this digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.Update(System.Byte)">
             update the message digest with a single byte.
            
             @param inByte the input byte to be entered.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
             update the message digest with a block of bytes.
            
             @param input the byte array containing the data.
             @param inOff the offset into the byte array where the data starts.
             @param len the length of the data.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.DoFinal(System.Byte[],System.Int32)">
             Close the digest, producing the final digest value. The doFinal
             call leaves the digest reset.
            
             @param output the array the digest is to be copied into.
             @param outOff the offset into the out array the digest is to start at.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.Reset">
            reset the digest back to it's initial state.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IMac">
            The base interface for implementations of message authentication codes (MACs).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.Init(Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the MAC.
            
             @param param the key and other data required by the MAC.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IMac.AlgorithmName">
             Return the name of the algorithm the MAC implements.
            
             @return the name of the algorithm the MAC implements.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.GetMacSize">
             Return the block size for this MAC (in bytes).
            
             @return the block size for this MAC in bytes.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.Update(System.Byte)">
             add a single byte to the mac for processing.
            
             @param in the byte to be processed.
             @exception InvalidOperationException if the MAC is not initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            @param in the array containing the input.
            @param inOff the index in the array the data begins at.
            @param len the length of the input starting at inOff.
            @exception InvalidOperationException if the MAC is not initialised.
            @exception DataLengthException if there isn't enough data in in.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.DoFinal(System.Byte[],System.Int32)">
            Compute the final stage of the MAC writing the output to the out
            parameter.
            <p>
            doFinal leaves the MAC in the same state it was after the last init.
            </p>
            @param out the array the MAC is to be output to.
            @param outOff the offset into the out buffer the output is to start at.
            @exception DataLengthException if there isn't enough space in out.
            @exception InvalidOperationException if the MAC is not initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.Reset">
            Reset the MAC. At the end of resetting the MAC should be in the
            in the same state it was after the last init (if there was one).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.InvalidCipherTextException">
            this exception is thrown whenever we find something we don't expect in a
            message.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.InvalidCipherTextException.#ctor">
            base constructor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.InvalidCipherTextException.#ctor(System.String)">
             create a InvalidCipherTextException with the given message.
            
             @param message the message to be carried with the exception.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ISignatureFactory">
            <summary>
            Base interface for operators that serve as stream-based signature calculators.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.ISignatureFactory.AlgorithmDetails">
            <summary>The algorithm details object for this calculator.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISignatureFactory.CreateCalculator">
            <summary>
            Create a stream calculator for this signature calculator. The stream
            calculator is used for the actual operation of entering the data to be signed
            and producing the signature block.
            </summary>
            <returns>A calculator producing an IBlockResult with a signature in it.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.ISigner.AlgorithmName">
             Return the name of the algorithm the signer implements.
            
             @return the name of the algorithm the signer implements.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the signer for signing or verification.
            
             @param forSigning true if for signing, false otherwise
             @param param necessary parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using
            the key we were initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.VerifySignature(System.Byte[])">
            return true if the internal state represents the signature described
            in the passed in array.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.Reset">
            reset the internal state
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IStreamCalculator">
            <summary>
            Base interface for cryptographic operations such as Hashes, MACs, and Signatures which reduce a stream of data
            to a single value.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IStreamCalculator.Stream">
            <summary>Return a "sink" stream which only exists to update the implementing object.</summary>
            <returns>A stream to write to in order to update the implementing object.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IStreamCalculator.GetResult">
            <summary>
            Return the result of processing the stream. This value is only available once the stream
            has been closed.
            </summary>
            <returns>The result of processing the stream.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IVerifier">
            <summary>
            Operators that reduce their input to the validation of a signature produce this type.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IVerifier.IsVerified(System.Byte[])">
            <summary>
            Return true if the passed in data matches what is expected by the verification result.
            </summary>
            <param name="data">The bytes representing the signature.</param>
            <returns>true if the signature verifies, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IVerifier.IsVerified(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Return true if the length bytes from off in the source array match the signature
            expected by the verification result.
            </summary>
            <param name="source">Byte array containing the signature.</param>
            <param name="off">The offset into the source array where the signature starts.</param>
            <param name="length">The number of bytes in source making up the signature.</param>
            <returns>true if the signature verifies, false otherwise.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IVerifierFactory">
            <summary>
            Base interface for operators that serve as stream-based signature verifiers.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IVerifierFactory.AlgorithmDetails">
            <summary>The algorithm details object for this verifier.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IVerifierFactory.CreateCalculator">
            <summary>
            Create a stream calculator for this verifier. The stream
            calculator is used for the actual operation of entering the data to be verified
            and producing a result which can be used to verify the original signature.
            </summary>
            <returns>A calculator producing an IVerifier which can verify the signature.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IVerifierFactoryProvider">
            <summary>
            Base interface for a provider to support the dynamic creation of signature verifiers.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IVerifierFactoryProvider.CreateVerifierFactory(System.Object)">
            <summary>
            Return a signature verfier for signature algorithm described in the passed in algorithm details object.
            </summary>
            <param name="algorithmDetails">The details of the signature algorithm verification is required for.</param>
            <returns>A new signature verifier.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.HMac">
             HMAC implementation based on RFC2104
            
             H(K XOR opad, H(K XOR ipad, text))
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.HMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher">
            implements Cipher-Block-Chaining (CBC) mode on top of a simple cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of chaining.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/CBC".
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.GetBlockSize">
             return the block size of the underlying cipher.
            
             @return the block size of the underlying cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate chaining step for CBC mode encryption.
            
             @param in the array containing the data to be encrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate chaining step for CBC mode decryption.
            
             @param in the array containing the data to be decrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the decrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.GcmBlockCipher">
            <summary>
            Implements the Galois/Counter mode (GCM) detailed in
            NIST Special Publication 800-38D.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GcmBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <remarks>
            MAC sizes from 32 bits to 128 bits (must be a multiple of 8) are supported. The default is 128 bits.
            Sizes less than 96 are not recommended, but are supported for specialized applications.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher">
            <summary>
            A block cipher mode that includes authenticated encryption with a streaming mode
            and optional associated data.</summary>
            <see cref="T:Org.BouncyCastle.Crypto.Parameters.AeadParameters"/>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.GetUnderlyingCipher">
            <summary>The block cipher underlying this algorithm.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <remarks>Parameter can either be an AeadParameters or a ParametersWithIV object.</remarks>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.GetBlockSize">
            <returns>The block size for this cipher, in bytes.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.ProcessAadByte(System.Byte)">
            <summary>Add a single byte to the associated data check.</summary>
            <remarks>If the implementation supports it, this will be an online operation and will not retain the associated data.</remarks>
            <param name="input">The byte to be processed.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.ProcessAadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Add a sequence of bytes to the associated data check.</summary>
            <remarks>If the implementation supports it, this will be an online operation and will not retain the associated data.</remarks>
            <param name="inBytes">The input byte array.</param>
            <param name="inOff">The offset into the input array where the data to be processed starts.</param>
            <param name="len">The number of bytes to be processed.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             Encrypt/decrypt a single byte.
            
             @param input the byte to be processed.
             @param outBytes the output buffer the processed byte goes into.
             @param outOff the offset into the output byte array the processed data starts at.
             @return the number of bytes written to out.
             @exception DataLengthException if the output buffer is too small.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             Process a block of bytes from in putting the result into out.
            
             @param inBytes the input byte array.
             @param inOff the offset into the in array where the data to be processed starts.
             @param len the number of bytes to be processed.
             @param outBytes the output buffer the processed bytes go into.
             @param outOff the offset into the output byte array the processed data starts at.
             @return the number of bytes written to out.
             @exception DataLengthException if the output buffer is too small.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Finish the operation either appending or verifying the MAC at the end of the data.
            
             @param outBytes space for any resulting output data.
             @param outOff offset into out to start copying the data at.
             @return number of bytes written into out.
             @throws InvalidOperationException if the cipher is in an inappropriate state.
             @throws InvalidCipherTextException if the MAC fails to match.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.GetMac">
             Return the value of the MAC associated with the last stream processed.
            
             @return MAC for plaintext data.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.GetUpdateOutputSize(System.Int32)">
             Return the size of the output buffer required for a ProcessBytes
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to ProcessBytes
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.GetOutputSize(System.Int32)">
             Return the size of the output buffer required for a ProcessBytes plus a
             DoFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to ProcessBytes and DoFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.Reset">
            <summary>
            Reset the cipher to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Operators.X509Utilities.GetDigestAlgName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            Return the digest algorithm using one of the standard JCA string
            representations rather than the algorithm identifier (if possible).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Operators.Asn1SignatureFactory">
            <summary>
            Calculator factory class for signature generation in ASN.1 based profiles that use an AlgorithmIdentifier to preserve
            signature algorithm details.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Operators.Asn1SignatureFactory.#ctor(System.String,Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Base constructor.
            </summary>
            <param name="algorithm">The name of the signature algorithm to use.</param>
            <param name="privateKey">The private key to be used in the signing operation.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Operators.Asn1SignatureFactory.#ctor(System.String,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Constructor which also specifies a source of randomness to be used if one is required.
            </summary>
            <param name="algorithm">The name of the signature algorithm to use.</param>
            <param name="privateKey">The private key to be used in the signing operation.</param>
            <param name="random">The source of randomness to be used in signature calculation.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Operators.Asn1SignatureFactory.SignatureAlgNames">
            <summary>
            Allows enumeration of the signature names supported by the verifier provider.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactory">
            <summary>
            Verifier class for signature verification in ASN.1 based profiles that use an AlgorithmIdentifier to preserve
            signature algorithm details.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactory.#ctor(System.String,Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Base constructor.
            </summary>
            <param name="algorithm">The name of the signature algorithm to use.</param>
            <param name="publicKey">The public key to be used in the verification operation.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactoryProvider">
            <summary>
            Provider class which supports dynamic creation of signature verifiers.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactoryProvider.#ctor(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Base constructor - specify the public key to be used in verification.
            </summary>
            <param name="publicKey">The public key to be used in creating verifiers provided by this object.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactoryProvider.SignatureAlgNames">
            <summary>
            Allows enumeration of the signature names supported by the verifier provider.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding">
            Block cipher padders are expected to conform to this interface
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.Init(Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param param parameters, if any required.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
            @exception InvalidCipherTextException if the padding is badly formed
            or invalid.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher">
            A wrapper class that allows block ciphers to be used to process data in
            a piecemeal fashion with padding. The PaddedBufferedBlockCipher
            outputs a block only when the buffer is full and more data is being added,
            or on a doFinal (unless the current block in the buffer is a pad block).
            The default padding mechanism used is the one outlined in Pkcs5/Pkcs7.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             Create a buffered block cipher with the desired padding.
            
             @param cipher the underlying block cipher this buffering object wraps.
             @param padding the padding type.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Create a buffered block cipher Pkcs7 padding
            
             @param cipher the underlying block cipher this buffering object wraps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.GetOutputSize(System.Int32)">
             return the minimum size of the output buffer required for an update
             plus a doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer. If the buffer is currently
             full and padding needs to be added a call to doFinal will produce
             2 * GetBlockSize() bytes.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output or we are decrypting and the input is not block size aligned.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding">
            A padder that adds Pkcs7/Pkcs5 padding to a block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding.Init(Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random - a SecureRandom if available.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.AeadParameters.#ctor(Org.BouncyCastle.Crypto.Parameters.KeyParameter,System.Int32,System.Byte[])">
             Base constructor.
            
             @param key key to be used by underlying cipher
             @param macSize macSize in bits
             @param nonce nonce to be used
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.AeadParameters.#ctor(Org.BouncyCastle.Crypto.Parameters.KeyParameter,System.Int32,System.Byte[],System.Byte[])">
             Base constructor.
            
             @param key key to be used by underlying cipher
             @param macSize macSize in bits
             @param nonce nonce to be used
             @param associatedText associated text, if any
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.DigestRandomGenerator">
            Random generation based on the digest with counter. Calling AddSeedMaterial will
            always increase the entropy of the hash.
            <p>
            Internal access to the digest is synchronized so a single one of these can be shared.
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.IRandomGenerator">
            <remarks>Generic interface for objects generating random bytes.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.IRandomGenerator.AddSeedMaterial(System.Byte[])">
            <summary>Add more seed material to the generator.</summary>
            <param name="seed">A byte array to be mixed into the generator's state.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.IRandomGenerator.AddSeedMaterial(System.Int64)">
            <summary>Add more seed material to the generator.</summary>
            <param name="seed">A long value to be mixed into the generator's state.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.IRandomGenerator.NextBytes(System.Byte[])">
            <summary>Fill byte array with random values.</summary>
            <param name="bytes">Array to be filled.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.IRandomGenerator.NextBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Fill byte array with random values.</summary>
            <param name="bytes">Array to receive bytes.</param>
            <param name="start">Index to start filling at.</param>
            <param name="len">Length of segment to fill.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.ReversedWindowGenerator">
            <remarks>
            Takes bytes generated by an underling RandomGenerator and reverses the order in
            each small window (of configurable size).
            <p>
            Access to internals is synchronized so a single one of these can be shared.
            </p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.ReversedWindowGenerator.AddSeedMaterial(System.Byte[])">
            <summary>Add more seed material to the generator.</summary>
            <param name="seed">A byte array to be mixed into the generator's state.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.ReversedWindowGenerator.AddSeedMaterial(System.Int64)">
            <summary>Add more seed material to the generator.</summary>
            <param name="seed">A long value to be mixed into the generator's state.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.ReversedWindowGenerator.NextBytes(System.Byte[])">
            <summary>Fill byte array with random values.</summary>
            <param name="bytes">Array to be filled.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.ReversedWindowGenerator.NextBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Fill byte array with random values.</summary>
            <param name="bytes">Array to receive bytes.</param>
            <param name="start">Index to start filling at.</param>
            <param name="len">Length of segment to fill.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.ThreadedSeedGenerator">
            A thread based seed generator - one source of randomness.
            <p>
            Based on an idea from Marcus Lippert.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.ThreadedSeedGenerator.GenerateSeed(System.Int32,System.Boolean)">
            Generate seed bytes. Set fast to false for best quality.
            <p>
            If fast is set to true, the code should be round about 8 times faster when
            generating a long sequence of random bytes. 20 bytes of random values using
            the fast mode take less than half a second on a Nokia e70. If fast is set to false,
            it takes round about 2500 ms.
            </p>
            @param numBytes the number of bytes to generate
            @param fast true if fast mode should be used
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.#cctor">
            <summary>
            Load oid table.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the signer for signing or verification.
            
             @param forSigning true if for signing, false otherwise
             @param param necessary parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using
            the key we were initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.VerifySignature(System.Byte[])">
            return true if the internal state represents the signature described
            in the passed in array.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.AddMagnitudes(System.Int32[],System.Int32[])">
            return a = a + b - b preserved.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.CompareTo(System.Int32,System.Int32[],System.Int32,System.Int32[])">
            unsigned comparison on two arrays - note the arrays may
            start with leading zeros.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Divide(System.Int32[],System.Int32[])">
            return z = x / y - done in place (z value preserved, x contains the
            remainder)
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.IsProbablePrime(System.Int32)">
            return whether or not a BigInteger is probably prime with a
            probability of 1 - (1/2)**certainty.
            <p>From Knuth Vol 2, pg 395.</p>
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ExtEuclid(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger@)">
             Calculate the numbers u1, u2, and u3 such that:
            
             u1 * a + u2 * b = u3
            
             where u3 is the greatest common divider of a and b.
             a and b using the extended Euclid algorithm (refer p. 323
             of The Art of Computer Programming vol 2, 2nd ed).
             This also seems to have the side effect of calculating
             some form of multiplicative inverse.
            
             @param a    First number to calculate gcd for
             @param b    Second number to calculate gcd for
             @param u1Out      the return object for the u1 value
             @return     The greatest common divisor of a and b
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Square(System.Int32[],System.Int32[])">
            return w with w = x * x - w is assumed to have enough space.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Multiply(System.Int32[],System.Int32[],System.Int32[])">
            return x with x = y * z - x is assumed to have enough space.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.GetMQuote">
            Calculate mQuote = -m^(-1) mod b with b = 2^32 (32 = word size)
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.MultiplyMonty(System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.UInt32,System.Boolean)">
            Montgomery multiplication: a = x * y * R^(-1) mod m
            <br/>
            Based algorithm 14.36 of Handbook of Applied Cryptography.
            <br/>
            <li> m, x, y should have length n </li>
            <li> a should have length (n + 1) </li>
            <li> b = 2^32, R = b^n </li>
            <br/>
            The result is put in x
            <br/>
            NOTE: the indices of x, y, m, a different in HAC and in Java
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Remainder(System.Int32[],System.Int32[])">
            return x = x % y - done in place (y value preserved)
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ShiftLeft(System.Int32[],System.Int32)">
            do a left shift - this returns a new array.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ShiftRightInPlace(System.Int32,System.Int32[],System.Int32)">
            do a right shift - this does it in place.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ShiftRightOneInPlace(System.Int32,System.Int32[])">
            do a right shift by one - this does it in place.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Subtract(System.Int32,System.Int32[],System.Int32,System.Int32[])">
            returns x = x - y - we assume x is >= y
        </member>
        <member name="T:Org.BouncyCastle.Security.DigestUtilities">
            <remarks>
             Utility class for creating IDigest objects from their names/Oids
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Security.DigestUtilities.GetObjectIdentifier(System.String)">
            <summary>
            Returns a ObjectIdentifier for a given digest mechanism.
            </summary>
            <param name="mechanism">A string representation of the digest meanism.</param>
            <returns>A DerObjectIdentifier, null if the Oid is not available.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecureRandom.GetInstance(System.String)">
            <summary>
            Create and auto-seed an instance based on the given algorithm.
            </summary>
            <remarks>Equivalent to GetInstance(algorithm, true)</remarks>
            <param name="algorithm">e.g. "SHA256PRNG"</param>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecureRandom.GetInstance(System.String,System.Boolean)">
            <summary>
            Create an instance based on the given algorithm, with optional auto-seeding
            </summary>
            <param name="algorithm">e.g. "SHA256PRNG"</param>
            <param name="autoSeed">If true, the instance will be auto-seeded.</param>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecureRandom.#ctor(System.Byte[])">
            <remarks>
            To replicate existing predictable output, replace with GetInstance("SHA1PRNG", false), followed by SetSeed(seed)
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecureRandom.#ctor(Org.BouncyCastle.Crypto.Prng.IRandomGenerator)">
            <summary>Use the specified instance of IRandomGenerator as random source.</summary>
            <remarks>
            This constructor performs no seeding of either the <c>IRandomGenerator</c> or the
            constructed <c>SecureRandom</c>. It is the responsibility of the client to provide
            proper seed material as necessary/appropriate for the given <c>IRandomGenerator</c>
            implementation.
            </remarks>
            <param name="generator">The source to generate all random bytes from.</param>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecurityUtilityException.#ctor">
            base constructor.
        </member>
        <member name="M:Org.BouncyCastle.Security.SecurityUtilityException.#ctor(System.String)">
             create a SecurityUtilityException with the given message.
            
             @param message the message to be carried with the exception.
        </member>
        <member name="T:Org.BouncyCastle.Security.SignerUtilities">
            <summary>
             Signer Utility class contains methods that can not be specifically grouped into other classes.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Security.SignerUtilities.GetObjectIdentifier(System.String)">
            <summary>
            Returns an ObjectIdentifier for a given encoding.
            </summary>
            <param name="mechanism">A string representation of the encoding.</param>
            <returns>A DerObjectIdentifier, null if the OID is not available.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Arrays">
            <summary> General array utilities.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Arrays.AreEqual(System.Byte[],System.Byte[])">
            <summary>
            Are two arrays equal.
            </summary>
            <param name="a">Left side.</param>
            <param name="b">Right side.</param>
            <returns>True if equal.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Arrays.ConstantTimeAreEqual(System.Byte[],System.Byte[])">
            <summary>
            A constant time equals comparison - does not terminate early if
            test will fail.
            </summary>
            <param name="a">first array</param>
            <param name="b">second array</param>
            <returns>true if arrays equal, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Arrays.CopyOfRange(System.Byte[],System.Int32,System.Int32)">
             Make a copy of a range of bytes from the passed in data array. The range can
             extend beyond the end of the input array, in which case the return array will
             be padded with zeroes.
            
             @param data the array from which the data is to be copied.
             @param from the start index at which the copying should take place.
             @param to the final index of the range (exclusive).
            
             @return a new byte array containing the range given.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.BigIntegers">
            BigInteger utilities.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.BigIntegers.AsUnsignedByteArray(Org.BouncyCastle.Math.BigInteger)">
             Return the passed in value as an unsigned byte array.
            
             @param value value to be converted.
             @return a byte array without a leading zero byte if present in the signed encoding.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.BigIntegers.AsUnsignedByteArray(System.Int32,Org.BouncyCastle.Math.BigInteger)">
             Return the passed in value as an unsigned byte array of specified length, zero-extended as necessary.
            
             @param length desired length of result array.
             @param n value to be converted.
             @return a byte array of specified length, with leading zeroes as necessary given the size of n.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.BigIntegers.CreateRandomInRange(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Security.SecureRandom)">
            Return a random BigInteger not less than 'min' and not greater than 'max'
            
            @param min the least value that may be generated
            @param max the greatest value that may be generated
            @param random the source of randomness
            @return a random BigInteger value in the range [min,max]
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Date.DateTimeUtilities.DateTimeToUnixMs(System.DateTime)">
            <summary>
            Return the number of milliseconds since the Unix epoch (1 Jan., 1970 UTC) for a given DateTime value.
            </summary>
            <param name="dateTime">A UTC DateTime value not before epoch.</param>
            <returns>Number of whole milliseconds after epoch.</returns>
            <exception cref="T:System.ArgumentException">'dateTime' is before epoch.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Date.DateTimeUtilities.UnixMsToDateTime(System.Int64)">
            <summary>
            Create a DateTime value from the number of milliseconds since the Unix epoch (1 Jan., 1970 UTC).
            </summary>
            <param name="unixMs">Number of milliseconds since the epoch.</param>
            <returns>A UTC DateTime value</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Date.DateTimeUtilities.CurrentUnixMs">
            <summary>
            Return the current number of milliseconds since the Unix epoch (1 Jan., 1970 UTC).
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.Hex">
            <summary>
            Class to decode and encode Hex.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[])">
             encode the input data producing a Hex encoded byte array.
            
             @return a byte array containing the Hex encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.Int32,System.Int32)">
             encode the input data producing a Hex encoded byte array.
            
             @return a byte array containing the Hex encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.IO.Stream)">
             Hex encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             Hex encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Decode(System.Byte[])">
             decode the Hex encoded input data. It is assumed the input data is valid.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Decode(System.String)">
             decode the Hex encoded string data - whitespace will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Decode(System.String,System.IO.Stream)">
             decode the Hex encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexEncoder.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             encode the input data producing a Hex output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexEncoder.Decode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             decode the Hex encoded byte data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexEncoder.DecodeString(System.String,System.IO.Stream)">
             decode the Hex encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.IEncoder">
            Encode and decode byte arrays (typically from binary to 7-bit ASCII
            encodings).
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IMemoable.Copy">
            <summary>
            Produce a copy of this object with its configuration and in its current state.
            </summary>
            <remarks>
            The returned object may be used simply to store the state, or may be used as a similar object
            starting from the copied state.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IMemoable.Reset(Org.BouncyCastle.Utilities.IMemoable)">
            <summary>
            Restore a copied object state into this object.
            </summary>
            <remarks>
            Implementations of this method <em>should</em> try to avoid or minimise memory allocation to perform the reset.
            </remarks>
            <param name="other">an object originally {@link #copy() copied} from an object of the same type as this instance.</param>
            <exception cref="T:System.InvalidCastException">if the provided object is not of the correct type.</exception>
            <exception cref="!:MemoableResetException">if the <b>other</b> parameter is in some other way invalid.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Streams.PipeAllLimited(System.IO.Stream,System.Int64,System.IO.Stream)">
            <summary>
            Pipe all bytes from <c>inStr</c> to <c>outStr</c>, throwing <c>StreamFlowException</c> if greater
            than <c>limit</c> bytes in <c>inStr</c>.
            </summary>
            <param name="inStr">
            A <see cref="T:System.IO.Stream"/>
            </param>
            <param name="limit">
            A <see cref="T:System.Int64"/>
            </param>
            <param name="outStr">
            A <see cref="T:System.IO.Stream"/>
            </param>
            <returns>The number of bytes actually transferred, if not greater than <c>limit</c></returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValid(System.String)">
             Validate the given IPv4 or IPv6 address.
            
             @param address the IP address as a string.
            
             @return true if a valid address, false otherwise
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValidWithNetMask(System.String)">
             Validate the given IPv4 or IPv6 address and netmask.
            
             @param address the IP address as a string.
            
             @return true if a valid address with netmask, false otherwise
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValidIPv4(System.String)">
             Validate the given IPv4 address.
             
             @param address the IP address as a string.
            
             @return true if a valid IPv4 address, false otherwise
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValidIPv6(System.String)">
             Validate the given IPv6 address.
            
             @param address the IP address as a string.
            
             @return true if a valid IPv4 address, false otherwise
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Strings">
            <summary> General string utilities.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.IX509Extension.GetCriticalExtensionOids">
            <summary>
            Get all critical extension values, by oid
            </summary>
            <returns>IDictionary with string (OID) keys and Asn1OctetString values</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.IX509Extension.GetNonCriticalExtensionOids">
            <summary>
            Get all non-critical extension values, by oid
            </summary>
            <returns>IDictionary with string (OID) keys and Asn1OctetString values</returns>
        </member>
        <member name="T:Org.BouncyCastle.X509.X509Certificate">
            <summary>
            An Object representing an X509 Certificate.
            Has static methods for loading Certificates encoded in many forms that return X509Certificate Objects.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.IsValidNow">
            <summary>
            Return true if the current time is within the start and end times nominated on the certificate.
            </summary>
            <returns>true id certificate is valid for the current time.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.IsValid(System.DateTime)">
            <summary>
            Return true if the nominated time is within the start and end times nominated on the certificate.
            </summary>
            <param name="time">The time to test validity against.</param>
            <returns>True if certificate is valid for nominated time.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.CheckValidity">
            <summary>
            Checks if the current date is within certificate's validity period.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.CheckValidity(System.DateTime)">
            <summary>
            Checks if the given date is within certificate's validity period.
            </summary>
            <exception cref="T:Org.BouncyCastle.Security.Certificates.CertificateExpiredException">if the certificate is expired by given date</exception>
            <exception cref="T:Org.BouncyCastle.Security.Certificates.CertificateNotYetValidException">if the certificate is not yet valid on given date</exception>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.Version">
            <summary>
            Return the certificate's version.
            </summary>
            <returns>An integer whose value Equals the version of the cerficate.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SerialNumber">
            <summary>
            Return a <see cref="T:Org.BouncyCastle.Math.BigInteger">BigInteger</see> containing the serial number.
            </summary>
            <returns>The Serial number.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.IssuerDN">
            <summary>
            Get the Issuer Distinguished Name. (Who signed the certificate.)
            </summary>
            <returns>And X509Object containing name and value pairs.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SubjectDN">
            <summary>
            Get the subject of this certificate.
            </summary>
            <returns>An X509Name object containing name and value pairs.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.NotBefore">
            <summary>
            The time that this certificate is valid from.
            </summary>
            <returns>A DateTime object representing that time in the local time zone.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.NotAfter">
            <summary>
            The time that this certificate is valid up to.
            </summary>
            <returns>A DateTime object representing that time in the local time zone.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetTbsCertificate">
            <summary>
            Return the Der encoded TbsCertificate data.
            This is the certificate component less the signature.
            To Get the whole certificate call the GetEncoded() member.
            </summary>
            <returns>A byte array containing the Der encoded Certificate component.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetSignature">
            <summary>
            The signature.
            </summary>
            <returns>A byte array containg the signature of the certificate.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SigAlgName">
            <summary>
            A meaningful version of the Signature Algorithm. (EG SHA1WITHRSA)
            </summary>
            <returns>A sting representing the signature algorithm.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SigAlgOid">
            <summary>
            Get the Signature Algorithms Object ID.
            </summary>
            <returns>A string containg a '.' separated object id.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetSigAlgParams">
            <summary>
            Get the signature algorithms parameters. (EG DSA Parameters)
            </summary>
            <returns>A byte array containing the Der encoded version of the parameters or null if there are none.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.IssuerUniqueID">
            <summary>
            Get the issuers UID.
            </summary>
            <returns>A DerBitString.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SubjectUniqueID">
            <summary>
            Get the subjects UID.
            </summary>
            <returns>A DerBitString.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetKeyUsage">
            <summary>
            Get a key usage guidlines.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetPublicKey">
            <summary>
            Get the public key of the subject of the certificate.
            </summary>
            <returns>The public key parameters.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetEncoded">
            <summary>
            Return a Der encoded version of this certificate.
            </summary>
            <returns>A byte array.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.Verify(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Verify the certificate's signature using the nominated public key.
            </summary>
            <param name="key">An appropriate public key parameter object, RsaPublicKeyParameters, DsaPublicKeyParameters or ECDsaPublicKeyParameters</param>
            <returns>True if the signature is valid.</returns>
            <exception cref="T:System.Exception">If key submitted is not of the above nominated types.</exception>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.Verify(Org.BouncyCastle.Crypto.IVerifierFactoryProvider)">
            <summary>
            Verify the certificate's signature using a verifier created using the passed in verifier provider.
            </summary>
            <param name="verifierProvider">An appropriate provider for verifying the certificate's signature.</param>
            <returns>True if the signature is valid.</returns>
            <exception cref="T:System.Exception">If verifier provider is not appropriate or the certificate algorithm is invalid.</exception>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509ExtensionBase.GetNonCriticalExtensionOids">
            <summary>
            Get non critical extensions.
            </summary>
            <returns>A set of non critical extension oids.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509ExtensionBase.GetCriticalExtensionOids">
            <summary>
            Get any critical extensions.
            </summary>
            <returns>A sorted list of critical entension.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509ExtensionBase.GetExtensionValue(System.String)">
            <summary>
            Get the value of a given extension.
            </summary>
            <param name="oid">The object ID of the extension. </param>
            <returns>An Asn1OctetString object if that extension is found or null if not.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509SignatureUtilities.GetDigestAlgName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            Return the digest algorithm using one of the standard JCA string
            representations rather than the algorithm identifier (if possible).
        </member>
    </members>
</doc>
